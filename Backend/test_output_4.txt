/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pytest_asyncio/plugin.py:208: PytestDeprecationWarning: The configuration option "asyncio_default_fixture_loop_scope" is unset.
The event loop scope for asynchronous fixtures will default to the fixture caching scope. Future versions of pytest-asyncio will default the loop scope for asynchronous fixtures to function scope. Set the default fixture loop scope explicitly in order to avoid unexpected behavior in the future. Valid fixture loop scopes are: "function", "class", "module", "package", "session"

  warnings.warn(PytestDeprecationWarning(_DEFAULT_FIXTURE_LOOP_SCOPE_UNSET))
============================= test session starts ==============================
platform darwin -- Python 3.13.5, pytest-8.3.4, pluggy-1.6.0 -- /Library/Frameworks/Python.framework/Versions/3.13/bin/python3
cachedir: .pytest_cache
rootdir: /Volumes/Stuff/Start Ups/MoranERP/Backend
configfile: pytest.ini
testpaths: tests
plugins: asyncio-0.24.0, allure-pytest-2.15.0, anyio-4.10.0, Faker-37.11.0, cov-7.0.0
asyncio: mode=Mode.STRICT, default_loop_scope=None
collecting ... collected 357 items

tests/integration/test_accounting_api.py::TestAccountingAPI::test_list_gl_entries FAILED [  0%]
tests/integration/test_accounting_api.py::TestAccountingAPI::test_list_journals FAILED [  0%]
tests/integration/test_accounting_api.py::TestAccountingAPI::test_list_accounts FAILED [  0%]
tests/integration/test_accounting_api.py::TestAccountingAPI::test_create_journal_entry FAILED [  1%]
tests/integration/test_auth_api.py::TestAuthAPI::test_login_success FAILED [  1%]
tests/integration/test_auth_api.py::TestAuthAPI::test_login_invalid_credentials FAILED [  1%]
tests/integration/test_auth_api.py::TestAuthAPI::test_login_with_tenant_success FAILED [  1%]
tests/integration/test_auth_api.py::TestAuthAPI::test_login_with_tenant_no_membership FAILED [  2%]
tests/integration/test_auth_api.py::TestAuthAPI::test_get_user_memberships FAILED [  2%]
tests/integration/test_crm_api.py::TestCRMAPI::test_list_contacts FAILED [  2%]
tests/integration/test_crm_api.py::TestCRMAPI::test_list_customers FAILED [  3%]
tests/integration/test_crm_api.py::TestCRMAPI::test_create_lead FAILED   [  3%]
tests/integration/test_erp_api.py::TestERPAPI::test_list_domain_partners PASSED [  3%]
tests/integration/test_erp_modules_api.py::TestERPModulesAPI::test_list_erp_modules FAILED [  3%]
tests/integration/test_erp_modules_api.py::TestERPModulesAPI::test_enable_erp_module PASSED [  4%]
tests/integration/test_erpnext_api.py::TestERPNextAPI::test_list_resource PASSED [  4%]
tests/integration/test_erpnext_api.py::TestERPNextAPI::test_get_resource PASSED [  4%]
tests/integration/test_erpnext_api.py::TestERPNextAPI::test_create_resource PASSED [  5%]
tests/integration/test_erpnext_api.py::TestERPNextAPI::test_update_resource PASSED [  5%]
tests/integration/test_erpnext_api.py::TestERPNextAPI::test_delete_resource PASSED [  5%]
tests/integration/test_erpnext_api.py::TestERPNextAPI::test_execute_method PASSED [  5%]
tests/integration/test_hr_api.py::TestHRAPI::test_list_employees FAILED  [  6%]
tests/integration/test_hr_api.py::TestHRAPI::test_create_employee FAILED [  6%]
tests/integration/test_hr_api.py::TestHRAPI::test_list_attendance FAILED [  6%]
tests/integration/test_inventory_api.py::TestInventoryAPI::test_list_items FAILED [  7%]
tests/integration/test_inventory_api.py::TestInventoryAPI::test_create_item FAILED [  7%]
tests/integration/test_inventory_api.py::TestInventoryAPI::test_get_item FAILED [  7%]
tests/integration/test_inventory_api.py::TestInventoryAPI::test_list_warehouses FAILED [  7%]
tests/integration/test_inventory_api.py::TestInventoryAPI::test_get_stock_balance FAILED [  8%]
tests/integration/test_manufacturing_api.py::TestManufacturingAPI::test_list_boms PASSED [  8%]
tests/integration/test_manufacturing_api.py::TestManufacturingAPI::test_list_work_orders FAILED [  8%]
tests/integration/test_onboarding_api.py::TestOnboardingAPI::test_get_onboarding_status PASSED [  8%]
tests/integration/test_onboarding_api.py::TestOnboardingAPI::test_start_onboarding PASSED [  9%]
tests/integration/test_onboarding_api.py::TestOnboardingAPI::test_execute_onboarding_step PASSED [  9%]
tests/integration/test_phase5_api.py::TestReportsAPI::test_list_report_types PASSED [  9%]
tests/integration/test_phase5_api.py::TestReportsAPI::test_list_report_types_returns_valid_structure PASSED [ 10%]
tests/integration/test_phase5_api.py::TestReportsAPI::test_generate_sales_report PASSED [ 10%]
tests/integration/test_phase5_api.py::TestReportsAPI::test_generate_inventory_report PASSED [ 10%]
tests/integration/test_phase5_api.py::TestReportsAPI::test_generate_finance_report PASSED [ 10%]
tests/integration/test_phase5_api.py::TestReportsAPI::test_stock_levels_endpoint PASSED [ 11%]
tests/integration/test_phase5_api.py::TestCommissionsAPI::test_list_commissions PASSED [ 11%]
tests/integration/test_phase5_api.py::TestCommissionsAPI::test_get_commission_summary PASSED [ 11%]
tests/integration/test_phase5_api.py::TestCommissionsAPI::test_get_commission_summary_with_group_by PASSED [ 12%]
tests/integration/test_phase5_api.py::TestCommissionsAPI::test_calculate_commissions PASSED [ 12%]
tests/integration/test_phase5_api.py::TestCommissionsAPI::test_get_commission_rates PASSED [ 12%]
tests/integration/test_phase5_api.py::TestDashboardAPI::test_get_dashboard_metrics PASSED [ 12%]
tests/integration/test_phase5_api.py::TestDashboardAPI::test_get_dashboard_metrics_with_period PASSED [ 13%]
tests/integration/test_phase5_api.py::TestDashboardAPI::test_get_module_metrics PASSED [ 13%]
tests/integration/test_phase5_api.py::TestDashboardAPI::test_get_quick_stats PASSED [ 13%]
tests/integration/test_phase5_api.py::TestDashboardAPI::test_get_dashboard_alerts PASSED [ 14%]
tests/integration/test_phase5_api.py::TestFilesAPI::test_list_files PASSED [ 14%]
tests/integration/test_phase5_api.py::TestFilesAPI::test_upload_file PASSED [ 14%]
tests/integration/test_phase5_api.py::TestFilesAPI::test_upload_file_validates_extension PASSED [ 14%]
tests/integration/test_phase5_api.py::TestNotificationsAPI::test_list_notifications PASSED [ 15%]
tests/integration/test_phase5_api.py::TestNotificationsAPI::test_get_unread_count PASSED [ 15%]
tests/integration/test_phase5_api.py::TestNotificationsAPI::test_create_notification PASSED [ 15%]
tests/integration/test_phase5_api.py::TestNotificationsAPI::test_mark_notification_read PASSED [ 15%]
tests/integration/test_phase5_api.py::TestNotificationsAPI::test_mark_all_read PASSED [ 16%]
tests/integration/test_phase5_api.py::TestNotificationsAPI::test_delete_notification PASSED [ 16%]
tests/integration/test_phase5_api.py::TestNotificationsAPI::test_clear_all_notifications PASSED [ 16%]
tests/integration/test_phase5_api.py::TestAPIResponseStructure::test_reports_types_structure PASSED [ 17%]
tests/integration/test_phase5_api.py::TestAPIResponseStructure::test_dashboard_metrics_structure PASSED [ 17%]
tests/integration/test_phase5_api.py::TestAPIResponseStructure::test_commissions_list_structure PASSED [ 17%]
tests/integration/test_pos_invoice_integration.py::TestPOSInvoiceIntegration::test_complete_invoice_creation_flow FAILED [ 17%]
tests/integration/test_pos_invoice_integration.py::TestPOSInvoiceIntegration::test_vat_calculation_integration FAILED [ 18%]
tests/integration/test_pos_invoice_integration.py::TestPOSInvoiceIntegration::test_gl_distribution_integration FAILED [ 18%]
tests/integration/test_pos_invoice_integration.py::TestPOSInvoiceIntegration::test_pos_profile_validation FAILED [ 18%]
tests/integration/test_pos_invoice_integration.py::TestPOSInvoiceIntegration::test_payment_amount_validation FAILED [ 19%]
tests/integration/test_pos_invoice_integration.py::TestPOSInvoiceIntegration::test_offline_transaction_queue FAILED [ 19%]
tests/integration/test_pos_invoice_integration.py::TestPOSInvoiceIntegration::test_api_response_format FAILED [ 19%]
tests/integration/test_pos_invoice_integration.py::TestPOSInvoiceIntegration::test_error_response_format PASSED [ 19%]
tests/integration/test_pos_invoice_integration.py::TestPOSInvoiceIntegration::test_plugin_system_integration PASSED [ 20%]
tests/integration/test_pos_invoice_integration.py::TestPOSInvoiceIntegration::test_tenant_isolation PASSED [ 20%]
tests/integration/test_projects_api.py::TestProjectsAPI::test_list_projects FAILED [ 20%]
tests/integration/test_projects_api.py::TestProjectsAPI::test_list_tasks FAILED [ 21%]
tests/integration/test_projects_api.py::TestProjectsAPI::test_create_project FAILED [ 21%]
tests/integration/test_provisioning_api.py::TestProvisioningAPI::test_start_provisioning_success ERROR [ 21%]
tests/integration/test_provisioning_api.py::TestProvisioningAPI::test_start_provisioning_engine_offline ERROR [ 21%]
tests/integration/test_provisioning_api.py::TestProvisioningAPI::test_get_provisioning_status ERROR [ 22%]
tests/integration/test_provisioning_api.py::TestProvisioningAPI::test_get_provisioning_status_not_started ERROR [ 22%]
tests/integration/test_provisioning_api.py::TestProvisioningAPI::test_retry_provisioning ERROR [ 22%]
tests/integration/test_provisioning_api.py::TestProvisioningAPI::test_skip_step ERROR [ 22%]
tests/integration/test_provisioning_api.py::TestProvisioningAPI::test_get_provisioning_logs ERROR [ 23%]
tests/integration/test_provisioning_api.py::TestProvisioningAPI::test_concurrent_provisioning_prevention ERROR [ 23%]
tests/integration/test_provisioning_e2e.py::TestProvisioningE2E::test_e2e_workspace_to_pos_ready ERROR [ 23%]
tests/integration/test_provisioning_e2e.py::TestProvisioningE2E::test_e2e_pos_invoice_after_provisioning ERROR [ 24%]
tests/integration/test_provisioning_e2e.py::TestProvisioningE2E::test_e2e_verify_all_resources_created ERROR [ 24%]
tests/integration/test_purchases_api.py::TestPurchasesAPI::test_list_purchase_orders FAILED [ 24%]
tests/integration/test_purchases_api.py::TestPurchasesAPI::test_create_purchase_order PASSED [ 24%]
tests/integration/test_rbac_api.py::TestRBACAPI::test_list_roles PASSED  [ 25%]
tests/integration/test_rbac_api.py::TestRBACAPI::test_get_role_permissions PASSED [ 25%]
tests/integration/test_rbac_api.py::TestRBACAPI::test_assign_role_to_user PASSED [ 25%]
tests/integration/test_rbac_api.py::TestRBACAPI::test_revoke_role_from_user PASSED [ 26%]
tests/integration/test_rbac_api.py::TestRBACAPI::test_check_permission PASSED [ 26%]
tests/integration/test_tenant_settings_api.py::TestTenantSettingsAPI::test_get_tenant_settings PASSED [ 26%]
tests/integration/test_tenant_settings_api.py::TestTenantSettingsAPI::test_update_tenant_settings PASSED [ 26%]
tests/integration/test_tenant_settings_api.py::TestTenantSettingsAPI::test_tenant_settings_feature_toggles PASSED [ 27%]
tests/integration/test_tenant_settings_api.py::TestTenantSettingsAPI::test_tenant_settings_validation PASSED [ 27%]
tests/test_health.py::test_health_check FAILED                           [ 27%]
tests/test_health.py::test_root FAILED                                   [ 28%]
tests/unit/test_auth_service.py::TestAuthService::test_verify_password_success PASSED [ 28%]
tests/unit/test_auth_service.py::TestAuthService::test_verify_password_failure PASSED [ 28%]
tests/unit/test_auth_service.py::TestAuthService::test_get_password_hash PASSED [ 28%]
tests/unit/test_auth_service.py::TestAuthService::test_create_access_token_default_expiry PASSED [ 29%]
tests/unit/test_auth_service.py::TestAuthService::test_create_access_token_custom_expiry PASSED [ 29%]
tests/unit/test_auth_service.py::TestAuthService::test_authenticate_user_success PASSED [ 29%]
tests/unit/test_auth_service.py::TestAuthService::test_authenticate_user_not_found PASSED [ 29%]
tests/unit/test_auth_service.py::TestAuthService::test_authenticate_user_wrong_password PASSED [ 30%]
tests/unit/test_auth_service.py::TestAuthService::test_get_user_tenants_regular_user PASSED [ 30%]
tests/unit/test_auth_service.py::TestAuthService::test_get_user_tenants_super_admin PASSED [ 30%]
tests/unit/test_auth_service.py::TestAuthService::test_get_tenant_membership_found PASSED [ 31%]
tests/unit/test_auth_service.py::TestAuthService::test_get_tenant_membership_not_found PASSED [ 31%]
tests/unit/test_auth_service.py::TestAuthService::test_create_tenant_token_with_roles PASSED [ 31%]
tests/unit/test_auth_service.py::TestAuthService::test_create_tenant_token_without_db PASSED [ 31%]
tests/unit/test_cache_service.py::TestCacheService::test_cache_hit PASSED [ 32%]
tests/unit/test_cache_service.py::TestCacheService::test_cache_miss PASSED [ 32%]
tests/unit/test_cache_service.py::TestCacheService::test_cache_set PASSED [ 32%]
tests/unit/test_cache_service.py::TestCacheService::test_cache_invalidation PASSED [ 33%]
tests/unit/test_cache_service.py::TestCacheService::test_redis_unavailable_fallback PASSED [ 33%]
tests/unit/test_cache_service.py::TestCacheService::test_cache_key_format PASSED [ 33%]
tests/unit/test_cache_service.py::TestCacheService::test_role_permissions_cache PASSED [ 33%]
tests/unit/test_cache_service.py::TestCacheService::test_batch_invalidation PASSED [ 34%]
tests/unit/test_cache_service.py::TestCacheService::test_ttl_customization PASSED [ 34%]
tests/unit/test_cache_service.py::TestCacheService::test_cache_stats SKIPPED [ 34%]
tests/unit/test_cache_service.py::TestCachePerformance::test_cache_reduces_db_queries PASSED [ 35%]
tests/unit/test_cache_service.py::TestCachePerformance::test_cache_expiration PASSED [ 35%]
tests/unit/test_dependencies_auth.py::TestGetCurrentTokenPayload::test_get_token_payload_success PASSED [ 35%]
tests/unit/test_dependencies_auth.py::TestGetCurrentTokenPayload::test_get_token_payload_no_token PASSED [ 35%]
tests/unit/test_dependencies_auth.py::TestGetCurrentTokenPayload::test_get_token_payload_invalid_token PASSED [ 36%]
tests/unit/test_dependencies_auth.py::TestGetCurrentUser::test_get_current_user_success PASSED [ 36%]
tests/unit/test_dependencies_auth.py::TestGetCurrentUser::test_get_current_user_no_user_id PASSED [ 36%]
tests/unit/test_dependencies_auth.py::TestGetCurrentUser::test_get_current_user_defaults PASSED [ 36%]
tests/unit/test_dependencies_auth.py::TestRequireTenantAccess::test_require_tenant_access_success PASSED [ 37%]
tests/unit/test_dependencies_auth.py::TestRequireTenantAccess::test_require_tenant_access_super_admin FAILED [ 37%]
tests/unit/test_dependencies_auth.py::TestRequireTenantAccess::test_require_tenant_access_no_tenant PASSED [ 37%]
tests/unit/test_dependencies_auth.py::TestVerifyTenantAccess::test_verify_tenant_access_success PASSED [ 38%]
tests/unit/test_dependencies_auth.py::TestVerifyTenantAccess::test_verify_tenant_access_super_admin PASSED [ 38%]
tests/unit/test_dependencies_auth.py::TestVerifyTenantAccess::test_verify_tenant_access_mismatch PASSED [ 38%]
tests/unit/test_dependencies_permissions.py::TestRequirePermission::test_require_permission_super_admin PASSED [ 38%]
tests/unit/test_dependencies_permissions.py::TestRequirePermission::test_require_permission_has_permission PASSED [ 39%]
tests/unit/test_dependencies_permissions.py::TestRequirePermission::test_require_permission_no_permission PASSED [ 39%]
tests/unit/test_dependencies_permissions.py::TestRequirePermission::test_require_permission_no_user_id PASSED [ 39%]
tests/unit/test_dependencies_permissions.py::TestRequireAnyPermission::test_require_any_permission_super_admin PASSED [ 40%]
tests/unit/test_dependencies_permissions.py::TestRequireAnyPermission::test_require_any_permission_has_one PASSED [ 40%]
tests/unit/test_dependencies_permissions.py::TestRequireAnyPermission::test_require_any_permission_has_none PASSED [ 40%]
tests/unit/test_dependencies_permissions.py::TestRequireAllPermissions::test_require_all_permissions_super_admin PASSED [ 40%]
tests/unit/test_dependencies_permissions.py::TestRequireAllPermissions::test_require_all_permissions_has_all PASSED [ 41%]
tests/unit/test_dependencies_permissions.py::TestRequireAllPermissions::test_require_all_permissions_missing_one PASSED [ 41%]
tests/unit/test_dependencies_permissions.py::TestGetCurrentUserPermissions::test_get_current_user_permissions_success PASSED [ 41%]
tests/unit/test_dependencies_permissions.py::TestGetCurrentUserPermissions::test_get_current_user_permissions_no_user_id PASSED [ 42%]
tests/unit/test_dependencies_permissions.py::TestGetCurrentUserRoles::test_get_current_user_roles_success PASSED [ 42%]
tests/unit/test_dependencies_permissions.py::TestGetCurrentUserRoles::test_get_current_user_roles_empty PASSED [ 42%]
tests/unit/test_dependencies_tenant.py::TestGetTenantEngine::test_get_tenant_engine_success PASSED [ 42%]
tests/unit/test_dependencies_tenant.py::TestGetTenantEngine::test_get_tenant_engine_not_found PASSED [ 43%]
tests/unit/test_dependencies_tenant.py::TestGetTenantEngine::test_get_tenant_engine_no_tenant_id PASSED [ 43%]
tests/unit/test_dependencies_tenant.py::TestGetTenantEngine::test_get_tenant_engine_default PASSED [ 43%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_init PASSED [ 43%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_resolve_site_name_with_uuid PASSED [ 44%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_resolve_site_name_with_site_name PASSED [ 44%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_resolve_site_name_none PASSED [ 44%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_login_success FAILED [ 45%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_login_failure FAILED [ 45%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_login_exception FAILED [ 45%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_proxy_request_success FAILED [ 45%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_proxy_request_error_handling FAILED [ 46%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_proxy_request_non_json_error FAILED [ 46%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_proxy_request_stock_shortage_normalized PASSED [ 46%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_proxy_request_stock_shortage_with_datetime_and_customer PASSED [ 47%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_list_resource PASSED [ 47%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_create_resource PASSED [ 47%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_get_resource PASSED [ 47%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_update_resource PASSED [ 48%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_delete_resource PASSED [ 48%]
tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_execute_method PASSED [ 48%]
tests/unit/test_gl_distribution_service.py::TestGLDistributionService::test_build_gl_entries_cash_payment FAILED [ 49%]
tests/unit/test_gl_distribution_service.py::TestGLDistributionService::test_build_gl_entries_mpesa_payment FAILED [ 49%]
tests/unit/test_gl_distribution_service.py::TestGLDistributionService::test_build_gl_entries_multiple_payments FAILED [ 49%]
tests/unit/test_gl_distribution_service.py::TestGLDistributionService::test_build_gl_entries_multiple_items FAILED [ 49%]
tests/unit/test_gl_distribution_service.py::TestGLDistributionService::test_build_gl_entries_no_taxes FAILED [ 50%]
tests/unit/test_gl_distribution_service.py::TestGLDistributionService::test_validate_gl_entries_balanced PASSED [ 50%]
tests/unit/test_gl_distribution_service.py::TestGLDistributionService::test_validate_gl_entries_unbalanced PASSED [ 50%]
tests/unit/test_gl_distribution_service.py::TestGLDistributionService::test_validate_gl_entries_empty PASSED [ 50%]
tests/unit/test_gl_distribution_service.py::TestGLDistributionService::test_rounding_precision_gl_entries FAILED [ 51%]
tests/unit/test_iam_models.py::TestUserModel::test_user_creation PASSED  [ 51%]
tests/unit/test_iam_models.py::TestUserModel::test_user_password_hash PASSED [ 51%]
tests/unit/test_iam_models.py::TestTenantModel::test_tenant_creation PASSED [ 52%]
tests/unit/test_iam_models.py::TestTenantModel::test_tenant_status PASSED [ 52%]
tests/unit/test_iam_models.py::TestMembershipModel::test_membership_creation PASSED [ 52%]
tests/unit/test_iam_models.py::TestMembershipModel::test_membership_status PASSED [ 52%]
tests/unit/test_iam_models.py::TestStaffProfileModel::test_staff_profile_creation PASSED [ 53%]
tests/unit/test_iam_models.py::TestCapabilityModel::test_capability_creation PASSED [ 53%]
tests/unit/test_iam_models.py::TestCapabilityModel::test_capability_risk_levels PASSED [ 53%]
tests/unit/test_iam_models.py::TestKYCLogModel::test_kyc_log_creation PASSED [ 54%]
tests/unit/test_iam_models.py::TestTenantSettingsModel::test_tenant_settings_creation PASSED [ 54%]
tests/unit/test_iam_models.py::TestTenantSettingsModel::test_tenant_settings_feature_toggles PASSED [ 54%]
tests/unit/test_import_service.py::TestImportService::test_parse_csv_success PASSED [ 54%]
tests/unit/test_import_service.py::TestImportService::test_parse_csv_invalid_encoding PASSED [ 55%]
tests/unit/test_import_service.py::TestImportService::test_parse_csv_empty PASSED [ 55%]
tests/unit/test_import_service.py::TestImportService::test_validate_users_success PASSED [ 55%]
tests/unit/test_import_service.py::TestImportService::test_validate_users_missing_email PASSED [ 56%]
tests/unit/test_import_service.py::TestImportService::test_validate_users_duplicate_email_in_file PASSED [ 56%]
tests/unit/test_import_service.py::TestImportService::test_validate_users_existing_email PASSED [ 56%]
tests/unit/test_import_service.py::TestImportService::test_validate_users_invalid_role PASSED [ 56%]
tests/unit/test_import_service.py::TestImportService::test_import_users_success PASSED [ 57%]
tests/unit/test_import_service.py::TestImportService::test_import_users_tenant_not_found PASSED [ 57%]
tests/unit/test_import_service.py::TestImportService::test_import_users_skip_existing PASSED [ 57%]
tests/unit/test_import_service_expanded.py::TestImportServiceExpanded::test_import_inventory_items FAILED [ 57%]
tests/unit/test_import_service_expanded.py::TestImportServiceExpanded::test_import_warehouses FAILED [ 58%]
tests/unit/test_import_service_expanded.py::TestImportServiceExpanded::test_import_storefronts FAILED [ 58%]
tests/unit/test_import_service_expanded.py::TestImportServiceExpanded::test_import_users_with_existing FAILED [ 58%]
tests/unit/test_odoo_client.py::TestOdooClientAdapter::test_init PASSED  [ 59%]
tests/unit/test_odoo_client.py::TestOdooClientAdapter::test_authenticate_system_success PASSED [ 59%]
tests/unit/test_odoo_client.py::TestOdooClientAdapter::test_authenticate_system_failure PASSED [ 59%]
tests/unit/test_odoo_client.py::TestOdooClientAdapter::test_execute_kw_success PASSED [ 59%]
tests/unit/test_odoo_client.py::TestOdooClientAdapter::test_list_resource PASSED [ 60%]
tests/unit/test_odoo_client.py::TestOdooClientAdapter::test_get_resource PASSED [ 60%]
tests/unit/test_odoo_client.py::TestOdooClientAdapter::test_create_resource PASSED [ 60%]
tests/unit/test_odoo_client.py::TestOdooClientAdapter::test_update_resource PASSED [ 61%]
tests/unit/test_odoo_client.py::TestOdooClientAdapter::test_delete_resource PASSED [ 61%]
tests/unit/test_odoo_client.py::TestOdooClientAdapter::test_supports_transactions PASSED [ 61%]
tests/unit/test_odoo_client.py::TestOdooClientAdapter::test_supports_audit_trail PASSED [ 61%]
tests/unit/test_odoo_client.py::TestOdooClientAdapter::test_dict_to_domain PASSED [ 62%]
tests/unit/test_onboarding_service.py::TestOnboardingOrchestrator::test_initiate_onboarding_success FAILED [ 62%]
tests/unit/test_onboarding_service.py::TestOnboardingOrchestrator::test_initiate_onboarding_tenant_not_found PASSED [ 62%]
tests/unit/test_onboarding_service.py::TestOnboardingOrchestrator::test_get_onboarding_status_not_started PASSED [ 63%]
tests/unit/test_onboarding_service.py::TestOnboardingOrchestrator::test_resolve_module_order PASSED [ 63%]
tests/unit/test_onboarding_service_expanded.py::TestOnboardingOrchestratorExpanded::test_get_onboarding_status_completed PASSED [ 63%]
tests/unit/test_onboarding_service_expanded.py::TestOnboardingOrchestratorExpanded::test_get_onboarding_status_not_found PASSED [ 63%]
tests/unit/test_onboarding_service_expanded.py::TestOnboardingOrchestratorExpanded::test_skip_step_success FAILED [ 64%]
tests/unit/test_onboarding_service_expanded.py::TestOnboardingOrchestratorExpanded::test_skip_step_not_found FAILED [ 64%]
tests/unit/test_onboarding_service_expanded.py::TestOnboardingOrchestratorExpanded::test_execute_next_step_no_pending FAILED [ 64%]
tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_engine_check_success FAILED [ 64%]
tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_engine_check_offline FAILED [ 65%]
tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_company_creation_success FAILED [ 65%]
tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_company_creation_idempotent FAILED [ 65%]
tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_chart_of_accounts_success FAILED [ 66%]
tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_chart_of_accounts_idempotent FAILED [ 66%]
tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_warehouses_success FAILED [ 66%]
tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_warehouses_idempotent PASSED [ 66%]
tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_settings_success FAILED [ 67%]
tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_customer_success PASSED [ 67%]
tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_customer_idempotent PASSED [ 67%]
tests/unit/test_provisioning_service.py::TestProvisioningService::test_provisioning_full_flow_success FAILED [ 68%]
tests/unit/test_provisioning_service.py::TestProvisioningService::test_provisioning_critical_failure FAILED [ 68%]
tests/unit/test_rbac_models.py::TestRoleModel::test_role_creation PASSED [ 68%]
tests/unit/test_rbac_models.py::TestRoleModel::test_role_levels PASSED   [ 68%]
tests/unit/test_rbac_models.py::TestPermissionModel::test_permission_creation PASSED [ 69%]
tests/unit/test_rbac_models.py::TestPermissionModel::test_permission_code_format PASSED [ 69%]
tests/unit/test_rbac_models.py::TestUserRoleModel::test_user_role_creation PASSED [ 69%]
tests/unit/test_rbac_models.py::TestUserRoleModel::test_user_role_expired PASSED [ 70%]
tests/unit/test_rbac_models.py::TestUserRoleModel::test_user_role_active_status PASSED [ 70%]
tests/unit/test_rbac_models.py::TestRolePermissionModel::test_role_permission_creation PASSED [ 70%]
tests/unit/test_rbac_models.py::TestPermissionOverrideModel::test_permission_override_creation PASSED [ 70%]
tests/unit/test_rbac_models.py::TestPermissionOverrideModel::test_permission_override_expired PASSED [ 71%]
tests/unit/test_rbac_models.py::TestPermissionOverrideModel::test_permission_override_grant_types PASSED [ 71%]
tests/unit/test_rbac_models.py::TestRoleAuditLogModel::test_audit_log_creation PASSED [ 71%]
tests/unit/test_rbac_models.py::TestRoleAuditLogModel::test_audit_log_actions PASSED [ 71%]
tests/unit/test_rbac_service.py::TestPermissionChecking::test_exact_permission_match PASSED [ 72%]
tests/unit/test_rbac_service.py::TestPermissionChecking::test_wildcard_module_permission PASSED [ 72%]
tests/unit/test_rbac_service.py::TestPermissionChecking::test_wildcard_resource_permission PASSED [ 72%]
tests/unit/test_rbac_service.py::TestPermissionChecking::test_wildcard_all_permission PASSED [ 73%]
tests/unit/test_rbac_service.py::TestPermissionChecking::test_super_admin_bypass PASSED [ 73%]
tests/unit/test_rbac_service.py::TestPermissionChecking::test_permission_grant_override PASSED [ 73%]
tests/unit/test_rbac_service.py::TestPermissionChecking::test_permission_revoke_override PASSED [ 73%]
tests/unit/test_rbac_service.py::TestPermissionChecking::test_expired_override_ignored PASSED [ 74%]
tests/unit/test_rbac_service.py::TestPermissionChecking::test_no_permission PASSED [ 74%]
tests/unit/test_rbac_service.py::TestRoleManagement::test_assign_role_success PASSED [ 74%]
tests/unit/test_rbac_service.py::TestRoleManagement::test_assign_role_already_assigned PASSED [ 75%]
tests/unit/test_rbac_service.py::TestRoleManagement::test_revoke_role_success PASSED [ 75%]
tests/unit/test_rbac_service.py::TestRoleManagement::test_revoke_owner_role_fails PASSED [ 75%]
tests/unit/test_rbac_service.py::TestRoleManagement::test_expired_role_ignored PASSED [ 75%]
tests/unit/test_rbac_service.py::TestAuditLogging::test_audit_log_created_on_role_assignment PASSED [ 76%]
tests/unit/test_rbac_service.py::TestAuditLogging::test_audit_log_created_on_role_revocation PASSED [ 76%]
tests/unit/test_rbac_service.py::TestCacheIntegration::test_permission_check_uses_cache PASSED [ 76%]
tests/unit/test_rbac_service.py::TestCacheIntegration::test_cache_invalidated_on_role_change PASSED [ 77%]
tests/unit/test_rbac_service_expanded.py::TestRBACServiceExpanded::test_assign_role_success PASSED [ 77%]
tests/unit/test_rbac_service_expanded.py::TestRBACServiceExpanded::test_assign_role_already_assigned PASSED [ 77%]
tests/unit/test_rbac_service_expanded.py::TestRBACServiceExpanded::test_revoke_role_success PASSED [ 77%]
tests/unit/test_rbac_service_expanded.py::TestRBACServiceExpanded::test_revoke_role_not_found PASSED [ 78%]
tests/unit/test_rbac_service_expanded.py::TestRBACServiceExpanded::test_grant_permission_override PASSED [ 78%]
tests/unit/test_rbac_service_expanded.py::TestRBACServiceExpanded::test_revoke_permission_override PASSED [ 78%]
tests/unit/test_rbac_service_expanded.py::TestRBACServiceExpanded::test_revoke_permission_override_not_found PASSED [ 78%]
tests/unit/test_rbac_service_expanded.py::TestRBACServiceExpanded::test_audit_log PASSED [ 79%]
tests/unit/test_rbac_service_expanded.py::TestRBACServiceExpanded::test_get_user_roles_with_tenant PASSED [ 79%]
tests/unit/test_rbac_service_expanded.py::TestRBACServiceExpanded::test_get_user_roles_system_wide PASSED [ 79%]
tests/unit/test_rbac_service_expanded.py::TestRBACServiceExpanded::test_get_effective_permissions_with_overrides PASSED [ 80%]
tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_grant_permission_override_success FAILED [ 80%]
tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_grant_permission_override_existing FAILED [ 80%]
tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_revoke_permission_override_success FAILED [ 80%]
tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_revoke_permission_override_not_found FAILED [ 81%]
tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_audit_log_success PASSED [ 81%]
tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_get_user_roles_system_wide FAILED [ 81%]
tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_get_effective_permissions_with_wildcards FAILED [ 82%]
tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_has_permission_with_override FAILED [ 82%]
tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_has_permission_with_override_denied FAILED [ 82%]
tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_assign_role_with_expiry FAILED [ 82%]
tests/unit/test_response_normalizer.py::TestResponseNormalizer::test_normalize_erpnext_dict_with_message PASSED [ 83%]
tests/unit/test_response_normalizer.py::TestResponseNormalizer::test_normalize_erpnext_dict_without_message PASSED [ 83%]
tests/unit/test_response_normalizer.py::TestResponseNormalizer::test_normalize_erpnext_primitive PASSED [ 83%]
tests/unit/test_response_normalizer.py::TestResponseNormalizer::test_normalize_erpnext_list PASSED [ 84%]
tests/unit/test_response_normalizer.py::TestResponseNormalizer::test_normalize_odoo_dict PASSED [ 84%]
tests/unit/test_response_normalizer.py::TestResponseNormalizer::test_normalize_odoo_list PASSED [ 84%]
tests/unit/test_response_normalizer.py::TestResponseNormalizer::test_normalize_error PASSED [ 84%]
tests/unit/test_response_normalizer.py::TestResponseNormalizer::test_is_error_true PASSED [ 85%]
tests/unit/test_response_normalizer.py::TestResponseNormalizer::test_is_error_false PASSED [ 85%]
tests/unit/test_settings_router.py::TestSettingsRouter::test_get_tenant_settings_existing PASSED [ 85%]
tests/unit/test_settings_router.py::TestSettingsRouter::test_get_tenant_settings_create_defaults PASSED [ 85%]
tests/unit/test_settings_router.py::TestSettingsRouter::test_get_tenant_settings_tenant_not_found PASSED [ 86%]
tests/unit/test_settings_router.py::TestSettingsRouter::test_create_or_update_tenant_settings_new PASSED [ 86%]
tests/unit/test_settings_router.py::TestSettingsRouter::test_create_or_update_tenant_settings_existing PASSED [ 86%]
tests/unit/test_settings_router.py::TestSettingsRouter::test_patch_tenant_settings_partial_update PASSED [ 87%]
tests/unit/test_settings_router.py::TestSettingsRouter::test_patch_tenant_settings_create_if_not_exists PASSED [ 87%]
tests/unit/test_tenant_settings.py::TestTenantSettingsModel::test_tenant_settings_creation PASSED [ 87%]
tests/unit/test_tenant_settings.py::TestTenantSettingsModel::test_tenant_settings_defaults PASSED [ 87%]
tests/unit/test_tenant_settings.py::TestTenantSettingsModel::test_tenant_settings_feature_toggles PASSED [ 88%]
tests/unit/test_tenant_settings.py::TestTenantSettingsModel::test_tenant_settings_company_info PASSED [ 88%]
tests/unit/test_tenant_settings.py::TestTenantSettingsModel::test_tenant_settings_contact_info PASSED [ 88%]
tests/unit/test_tenant_settings.py::TestTenantSettingsModel::test_tenant_settings_address PASSED [ 89%]
tests/unit/test_tenant_settings.py::TestTenantSettingsModel::test_tenant_settings_financial_settings PASSED [ 89%]
tests/unit/test_tenant_settings.py::TestTenantSettingsModel::test_tenant_settings_business_info PASSED [ 89%]
tests/unit/test_tenant_settings.py::TestTenantSettingsModel::test_tenant_settings_configuration PASSED [ 89%]
tests/unit/test_tenant_settings.py::TestTenantSettingsModel::test_tenant_settings_setup_status PASSED [ 90%]
tests/unit/test_tenant_settings.py::TestTenantSettingsService::test_get_tenant_settings PASSED [ 90%]
tests/unit/test_tenant_settings.py::TestTenantSettingsService::test_create_tenant_settings PASSED [ 90%]
tests/unit/test_tenant_settings.py::TestTenantSettingsService::test_update_tenant_settings PASSED [ 91%]
tests/unit/test_tenant_settings.py::TestTenantSettingsService::test_tenant_settings_validation PASSED [ 91%]
tests/unit/test_tenant_settings.py::TestTenantSettingsService::test_tenant_settings_relationship PASSED [ 91%]
tests/unit/test_tenant_settings.py::TestTenantSettingsAPI::test_get_tenant_settings_endpoint PASSED [ 91%]
tests/unit/test_tenant_settings.py::TestTenantSettingsAPI::test_update_tenant_settings_endpoint PASSED [ 92%]
tests/unit/test_utils_codes.py::TestGenerateBase32Suffix::test_generate_base32_suffix_default PASSED [ 92%]
tests/unit/test_utils_codes.py::TestGenerateBase32Suffix::test_generate_base32_suffix_custom_length PASSED [ 92%]
tests/unit/test_utils_codes.py::TestGenerateEntityCode::test_generate_entity_code_default PASSED [ 92%]
tests/unit/test_utils_codes.py::TestGenerateEntityCode::test_generate_entity_code_with_country PASSED [ 93%]
tests/unit/test_utils_codes.py::TestGenerateEntityCode::test_generate_entity_code_with_year PASSED [ 93%]
tests/unit/test_utils_codes.py::TestGenerateEntityCode::test_generate_entity_code_custom_length PASSED [ 93%]
tests/unit/test_utils_codes.py::TestGenerateRoleCode::test_generate_role_code_system PASSED [ 94%]
tests/unit/test_utils_codes.py::TestGenerateRoleCode::test_generate_role_code_tenant PASSED [ 94%]
tests/unit/test_utils_codes.py::TestGenerateRoleCode::test_generate_role_code_custom PASSED [ 94%]
tests/unit/test_utils_codes.py::TestGenerateRoleCode::test_generate_role_code_custom_default_country PASSED [ 94%]
tests/unit/test_utils_codes.py::TestGenerateRoleCode::test_generate_role_code_system_with_db PASSED [ 95%]
tests/unit/test_utils_codes.py::TestGeneratePermissionCode::test_generate_permission_code_default PASSED [ 95%]
tests/unit/test_utils_codes.py::TestGeneratePermissionCode::test_generate_permission_code_with_module_abbreviation PASSED [ 95%]
tests/unit/test_utils_codes.py::TestGeneratePermissionCode::test_generate_permission_code_unknown_module PASSED [ 96%]
tests/unit/test_utils_codes.py::TestGeneratePermissionCode::test_generate_permission_code_with_db PASSED [ 96%]
tests/unit/test_utils_codes.py::TestConstants::test_prefix_constants PASSED [ 96%]
tests/unit/test_utils_codes.py::TestConstants::test_module_abbreviations PASSED [ 96%]
tests/unit/test_vat_service.py::TestVATService::test_calculate_vat_vatable_item FAILED [ 97%]
tests/unit/test_vat_service.py::TestVATService::test_calculate_vat_non_vatable_item FAILED [ 97%]
tests/unit/test_vat_service.py::TestVATService::test_calculate_vat_for_items_mixed FAILED [ 97%]
tests/unit/test_vat_service.py::TestVATService::test_calculate_vat_for_items_empty FAILED [ 98%]
tests/unit/test_vat_service.py::TestVATService::test_calculate_vat_for_items_none_values FAILED [ 98%]
tests/unit/test_vat_service.py::TestVATService::test_get_vat_account_with_type PASSED [ 98%]
tests/unit/test_vat_service.py::TestVATService::test_get_vat_account_default PASSED [ 98%]
tests/unit/test_vat_service.py::TestVATService::test_get_vat_account_not_found PASSED [ 99%]
tests/unit/test_vat_service.py::TestVATService::test_rounding_precision FAILED [ 99%]
tests/unit/test_vat_service.py::TestVATService::test_zero_amount_handling FAILED [ 99%]
tests/unit/test_vat_service.py::TestVATService::test_negative_amount_handling FAILED [100%]
ERROR: Coverage failure: total of 35.86 is less than fail-under=80.00


==================================== ERRORS ====================================
____ ERROR at setup of TestProvisioningAPI.test_start_provisioning_success _____

self = <sqlalchemy.engine.base.Connection object at 0x10fb46510>
engine = Engine(postgresql://postgres:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def db_engine():
        """Create test database tables once per session."""
        # Create all tables
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5868: in create_all
    bind._run_ddl_visitor(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3252: in _run_ddl_visitor
    with self.begin() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3242: in begin
    with self.connect() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3278: in connect
    return self._connection_cls(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:148: in __init__
    Connection._handle_dbapi_exception_noconnection(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2442: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: in __init__
    self._dbapi_connection = engine.raw_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestProvisioningAPI.test_start_provisioning_engine_offline _

self = <sqlalchemy.engine.base.Connection object at 0x10fb46510>
engine = Engine(postgresql://postgres:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def db_engine():
        """Create test database tables once per session."""
        # Create all tables
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5868: in create_all
    bind._run_ddl_visitor(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3252: in _run_ddl_visitor
    with self.begin() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3242: in begin
    with self.connect() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3278: in connect
    return self._connection_cls(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:148: in __init__
    Connection._handle_dbapi_exception_noconnection(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2442: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: in __init__
    self._dbapi_connection = engine.raw_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError
______ ERROR at setup of TestProvisioningAPI.test_get_provisioning_status ______

self = <sqlalchemy.engine.base.Connection object at 0x10fb46510>
engine = Engine(postgresql://postgres:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def db_engine():
        """Create test database tables once per session."""
        # Create all tables
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5868: in create_all
    bind._run_ddl_visitor(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3252: in _run_ddl_visitor
    with self.begin() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3242: in begin
    with self.connect() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3278: in connect
    return self._connection_cls(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:148: in __init__
    Connection._handle_dbapi_exception_noconnection(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2442: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: in __init__
    self._dbapi_connection = engine.raw_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestProvisioningAPI.test_get_provisioning_status_not_started _

self = <sqlalchemy.engine.base.Connection object at 0x10fb46510>
engine = Engine(postgresql://postgres:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def db_engine():
        """Create test database tables once per session."""
        # Create all tables
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5868: in create_all
    bind._run_ddl_visitor(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3252: in _run_ddl_visitor
    with self.begin() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3242: in begin
    with self.connect() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3278: in connect
    return self._connection_cls(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:148: in __init__
    Connection._handle_dbapi_exception_noconnection(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2442: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: in __init__
    self._dbapi_connection = engine.raw_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError
________ ERROR at setup of TestProvisioningAPI.test_retry_provisioning _________

self = <sqlalchemy.engine.base.Connection object at 0x10fb46510>
engine = Engine(postgresql://postgres:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def db_engine():
        """Create test database tables once per session."""
        # Create all tables
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5868: in create_all
    bind._run_ddl_visitor(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3252: in _run_ddl_visitor
    with self.begin() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3242: in begin
    with self.connect() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3278: in connect
    return self._connection_cls(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:148: in __init__
    Connection._handle_dbapi_exception_noconnection(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2442: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: in __init__
    self._dbapi_connection = engine.raw_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError
_____________ ERROR at setup of TestProvisioningAPI.test_skip_step _____________

self = <sqlalchemy.engine.base.Connection object at 0x10fb46510>
engine = Engine(postgresql://postgres:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def db_engine():
        """Create test database tables once per session."""
        # Create all tables
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5868: in create_all
    bind._run_ddl_visitor(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3252: in _run_ddl_visitor
    with self.begin() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3242: in begin
    with self.connect() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3278: in connect
    return self._connection_cls(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:148: in __init__
    Connection._handle_dbapi_exception_noconnection(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2442: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: in __init__
    self._dbapi_connection = engine.raw_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError
_______ ERROR at setup of TestProvisioningAPI.test_get_provisioning_logs _______

self = <sqlalchemy.engine.base.Connection object at 0x10fb46510>
engine = Engine(postgresql://postgres:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def db_engine():
        """Create test database tables once per session."""
        # Create all tables
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5868: in create_all
    bind._run_ddl_visitor(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3252: in _run_ddl_visitor
    with self.begin() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3242: in begin
    with self.connect() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3278: in connect
    return self._connection_cls(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:148: in __init__
    Connection._handle_dbapi_exception_noconnection(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2442: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: in __init__
    self._dbapi_connection = engine.raw_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestProvisioningAPI.test_concurrent_provisioning_prevention _

self = <sqlalchemy.engine.base.Connection object at 0x10fb46510>
engine = Engine(postgresql://postgres:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def db_engine():
        """Create test database tables once per session."""
        # Create all tables
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5868: in create_all
    bind._run_ddl_visitor(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3252: in _run_ddl_visitor
    with self.begin() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3242: in begin
    with self.connect() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3278: in connect
    return self._connection_cls(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:148: in __init__
    Connection._handle_dbapi_exception_noconnection(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2442: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: in __init__
    self._dbapi_connection = engine.raw_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError
____ ERROR at setup of TestProvisioningE2E.test_e2e_workspace_to_pos_ready _____

self = <sqlalchemy.engine.base.Connection object at 0x10fb46510>
engine = Engine(postgresql://postgres:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def db_engine():
        """Create test database tables once per session."""
        # Create all tables
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5868: in create_all
    bind._run_ddl_visitor(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3252: in _run_ddl_visitor
    with self.begin() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3242: in begin
    with self.connect() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3278: in connect
    return self._connection_cls(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:148: in __init__
    Connection._handle_dbapi_exception_noconnection(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2442: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: in __init__
    self._dbapi_connection = engine.raw_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestProvisioningE2E.test_e2e_pos_invoice_after_provisioning _

self = <sqlalchemy.engine.base.Connection object at 0x10fb46510>
engine = Engine(postgresql://postgres:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def db_engine():
        """Create test database tables once per session."""
        # Create all tables
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5868: in create_all
    bind._run_ddl_visitor(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3252: in _run_ddl_visitor
    with self.begin() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3242: in begin
    with self.connect() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3278: in connect
    return self._connection_cls(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:148: in __init__
    Connection._handle_dbapi_exception_noconnection(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2442: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: in __init__
    self._dbapi_connection = engine.raw_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestProvisioningE2E.test_e2e_verify_all_resources_created __

self = <sqlalchemy.engine.base.Connection object at 0x10fb46510>
engine = Engine(postgresql://postgres:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

    @pytest.fixture(scope="session")
    def db_engine():
        """Create test database tables once per session."""
        # Create all tables
>       Base.metadata.create_all(bind=engine)

tests/conftest.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/sql/schema.py:5868: in create_all
    bind._run_ddl_visitor(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3252: in _run_ddl_visitor
    with self.begin() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3242: in begin
    with self.connect() as conn:
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3278: in connect
    return self._connection_cls(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:148: in __init__
    Connection._handle_dbapi_exception_noconnection(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:2442: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:146: in __init__
    self._dbapi_connection = engine.raw_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/base.py:3302: in raw_connection
    return self.pool.connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:449: in connect
    return _ConnectionFairy._checkout(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:1263: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:712: in checkout
    rec = pool._do_get()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:179: in _do_get
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    return self._create_connection()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:390: in _create_connection
    return _ConnectionRecord(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:674: in __init__
    self.__connect()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:900: in __connect
    with util.safe_reraise():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/pool/base.py:896: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/create.py:643: in connect
    return dialect.connect(*cargs, **cparams)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/sqlalchemy/engine/default.py:621: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=postgres user=postgres password=mysecretpassword port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'mysecretpassword', 'port': 5432, ...}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: FATAL:  role "postgres" does not exist
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/psycopg2/__init__.py:122: OperationalError
=================================== FAILURES ===================================
____________________ TestAccountingAPI.test_list_gl_entries ____________________

self = <tests.integration.test_accounting_api.TestAccountingAPI object at 0x10f8e5d10>
mock_adapter = <MagicMock name='erpnext_adapter' id='4559264064'>
mock_check_permission = <MagicMock name='check_permission' id='4559264736'>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': 'c754b350-34d9-43a3-9157-ba46a0df04f1', 'user_code': 'USER001', ...}

    @patch('app.routers.accounting.check_permission')
    @patch('app.routers.accounting.erpnext_adapter')
    def test_list_gl_entries(self, mock_adapter, mock_check_permission, mock_user):
        """Test listing GL entries."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_token_payload] = lambda: mock_user
        app.dependency_overrides[get_db] = lambda: MagicMock()
    
        mock_check_permission.return_value = True
        mock_adapter.proxy_request.return_value = {
            "data": [
                {"name": "GL-001", "account": "Cash", "debit": 1000},
                {"name": "GL-002", "account": "Revenue", "credit": 1000}
            ]
        }
    
        try:
            response = client.get(
                f"/api/tenants/{tenant_id}/erp/accounting/gl-entries",
                headers={"Authorization": "Bearer test_token"}
            )
    
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_accounting_api.py:49: AssertionError
_____________________ TestAccountingAPI.test_list_journals _____________________

self = <tests.integration.test_accounting_api.TestAccountingAPI object at 0x10f8e6210>
mock_adapter = <MagicMock name='erpnext_adapter' id='4560099984'>
mock_check_permission = <MagicMock name='check_permission' id='4560100320'>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': '2bd160ed-3348-46ff-b113-a6e9154e3a7a', 'user_code': 'USER001', ...}

    @patch('app.routers.accounting.check_permission')
    @patch('app.routers.accounting.erpnext_adapter')
    def test_list_journals(self, mock_adapter, mock_check_permission, mock_user):
        """Test listing journal entries."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_token_payload] = lambda: mock_user
        app.dependency_overrides[get_db] = lambda: MagicMock()
    
        mock_check_permission.return_value = True
        mock_adapter.proxy_request.return_value = {
            "data": [
                {"name": "JNL-001", "voucher_type": "Journal Entry"}
            ]
        }
    
        try:
            response = client.get(
                f"/api/tenants/{tenant_id}/erp/accounting/journals",
                headers={"Authorization": "Bearer test_token"}
            )
    
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_accounting_api.py:74: AssertionError
_____________________ TestAccountingAPI.test_list_accounts _____________________

self = <tests.integration.test_accounting_api.TestAccountingAPI object at 0x10f78fbb0>
mock_adapter = <MagicMock name='erpnext_adapter' id='4560100992'>
mock_check_permission = <MagicMock name='check_permission' id='4560101328'>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': '65cb693f-8646-49c9-91d6-059574e2deed', 'user_code': 'USER001', ...}

    @patch('app.routers.accounting.check_permission')
    @patch('app.routers.accounting.erpnext_adapter')
    def test_list_accounts(self, mock_adapter, mock_check_permission, mock_user):
        """Test listing accounts."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_token_payload] = lambda: mock_user
        app.dependency_overrides[get_db] = lambda: MagicMock()
    
        mock_check_permission.return_value = True
        mock_adapter.proxy_request.return_value = {
            "data": [
                {"name": "Cash", "account_type": "Asset"},
                {"name": "Revenue", "account_type": "Income"}
            ]
        }
    
        try:
            response = client.get(
                f"/api/tenants/{tenant_id}/erp/accounting/accounts",
                headers={"Authorization": "Bearer test_token"}
            )
    
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_accounting_api.py:100: AssertionError
_________________ TestAccountingAPI.test_create_journal_entry __________________

self = <tests.integration.test_accounting_api.TestAccountingAPI object at 0x10f78fe10>
mock_adapter = <MagicMock name='erpnext_adapter' id='4559267088'>
mock_check_permission = <MagicMock name='check_permission' id='4559271456'>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': '6f6f71aa-8243-4c33-959f-718ed3b513bf', 'user_code': 'USER001', ...}

    @patch('app.routers.accounting.check_permission')
    @patch('app.routers.accounting.erpnext_adapter')
    def test_create_journal_entry(self, mock_adapter, mock_check_permission, mock_user):
        """Test creating journal entry."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_token_payload] = lambda: mock_user
        app.dependency_overrides[get_db] = lambda: MagicMock()
    
        mock_check_permission.return_value = True
        mock_adapter.proxy_request.return_value = {
            "data": {
                "name": "JNL-001",
                "voucher_type": "Journal Entry"
            }
        }
    
        try:
            response = client.post(
                f"/api/tenants/{tenant_id}/erp/accounting/journals",
                json={
                    "voucher_type": "Journal Entry",
                    "posting_date": "2026-01-09",
                    "accounts": [
                        {"account": "Cash", "debit": 1000},
                        {"account": "Revenue", "credit": 1000}
                    ]
                },
                headers={"Authorization": "Bearer test_token"}
            )
    
>           assert response.status_code in [200, 201]
E           assert 404 in [200, 201]
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_accounting_api.py:134: AssertionError
________________________ TestAuthAPI.test_login_success ________________________

self = <tests.integration.test_auth_api.TestAuthAPI object at 0x10f8e5bd0>
mock_get_db = <MagicMock name='get_db' id='4560099984'>
mock_auth_service = <MagicMock name='auth_service' id='4560100320'>
mock_user = <MagicMock name='auth_service.authenticate_user()' id='4559269776'>
mock_tenant = <MagicMock id='4560097632'>

    @patch('app.routers.auth.auth_service')
    @patch('app.routers.auth.get_db')
    def test_login_success(self, mock_get_db, mock_auth_service, mock_user, mock_tenant):
        """Test successful login."""
        # Mock database session
        mock_db = MagicMock()
        mock_get_db.return_value = mock_db
    
        # Mock authentication
        mock_auth_service.authenticate_user.return_value = mock_user
        mock_auth_service.get_user_tenants.return_value = [mock_tenant]
    
        # Set tenant attributes
        mock_tenant.name = "Test Tenant"
        mock_tenant.tenant_code = "TENANT001"
        mock_tenant.engine = "erpnext"
    
        response = client.post(
            "/auth/login",
            json={
                "email": "test@example.com",
                "password": "password123"
            }
        )
    
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_auth_api.py:66: AssertionError
__________________ TestAuthAPI.test_login_invalid_credentials __________________

self = <tests.integration.test_auth_api.TestAuthAPI object at 0x10f8e6fd0>
mock_get_db = <MagicMock name='get_db' id='4559267088'>
mock_auth_service = <MagicMock name='auth_service' id='4559271456'>

    @patch('app.routers.auth.auth_service')
    @patch('app.routers.auth.get_db')
    def test_login_invalid_credentials(self, mock_get_db, mock_auth_service):
        """Test login with invalid credentials."""
        mock_db = MagicMock()
        mock_get_db.return_value = mock_db
    
        # Mock authentication failure
        mock_auth_service.authenticate_user.return_value = None
    
        response = client.post(
            "/auth/login",
            json={
                "email": "test@example.com",
                "password": "wrong_password"
            }
        )
    
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_auth_api.py:93: AssertionError
__________________ TestAuthAPI.test_login_with_tenant_success __________________

self = <tests.integration.test_auth_api.TestAuthAPI object at 0x10f940050>
mock_get_db = <MagicMock name='get_db' id='4560103680'>
mock_auth_service = <MagicMock name='auth_service' id='4560104016'>
mock_user = <MagicMock name='auth_service.authenticate_user()' id='4560102672'>
mock_tenant = <MagicMock id='4560103008'>
mock_membership = <MagicMock name='auth_service.get_tenant_membership()' id='4560103344'>

    @patch('app.routers.auth.auth_service')
    @patch('app.routers.auth.get_db')
    def test_login_with_tenant_success(
        self, mock_get_db, mock_auth_service, mock_user, mock_tenant, mock_membership
    ):
        """Test successful login with tenant selection."""
        mock_db = MagicMock()
        mock_get_db.return_value = mock_db
    
        # Mock authentication and tenant lookup
        mock_auth_service.authenticate_user.return_value = mock_user
        mock_auth_service.get_user_tenants.return_value = [mock_tenant]
        mock_auth_service.get_tenant_membership.return_value = mock_membership
        mock_auth_service.create_tenant_token.return_value = "tenant_token_123"
    
        response = client.post(
            "/auth/v1/login-with-tenant",
            json={
                "email": "test@example.com",
                "password": "password123",
                "tenant_id": str(mock_tenant.id)
            }
        )
    
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_auth_api.py:121: AssertionError
_______________ TestAuthAPI.test_login_with_tenant_no_membership _______________

self = <tests.integration.test_auth_api.TestAuthAPI object at 0x10f940180>
mock_get_db = <MagicMock name='get_db' id='4558447888'>
mock_auth_service = <MagicMock name='auth_service' id='4560102336'>
mock_user = <MagicMock name='auth_service.authenticate_user()' id='4559271456'>
mock_tenant = <MagicMock id='4559267424'>

    @patch('app.routers.auth.auth_service')
    @patch('app.routers.auth.get_db')
    def test_login_with_tenant_no_membership(
        self, mock_get_db, mock_auth_service, mock_user, mock_tenant
    ):
        """Test login with tenant when user has no membership."""
        mock_db = MagicMock()
        mock_get_db.return_value = mock_db
    
        mock_auth_service.authenticate_user.return_value = mock_user
        mock_auth_service.get_user_tenants.return_value = []  # No tenants
        mock_auth_service.get_tenant_membership.return_value = None
    
        response = client.post(
            "/auth/v1/login-with-tenant",
            json={
                "email": "test@example.com",
                "password": "password123",
                "tenant_id": str(mock_tenant.id)
            }
        )
    
        # Endpoint returns 200 with require_tenant_selection if no membership
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_auth_api.py:149: AssertionError
____________________ TestAuthAPI.test_get_user_memberships _____________________

self = <tests.integration.test_auth_api.TestAuthAPI object at 0x10f8cb9b0>
mock_user = <MagicMock id='4560107376'>
mock_tenant = <MagicMock id='4560107712'>

    def test_get_user_memberships(self, mock_user, mock_tenant):
        """Test getting user memberships."""
        from app.dependencies.auth import get_current_user
        from app.database import get_db
    
        mock_db = MagicMock()
    
        # Override dependencies
        app.dependency_overrides[get_current_user] = lambda: {
            "user_id": str(mock_user.id),
            "email": mock_user.email
        }
        app.dependency_overrides[get_db] = lambda: mock_db
    
        # Mock membership and tenant query result
        mock_membership = MagicMock()
        mock_membership.status = "ACTIVE"
        mock_membership.role = "ADMIN"
    
        mock_tenant.id = uuid.uuid4()
        mock_tenant.name = "Test Tenant"
        mock_tenant.tenant_code = "TENANT001"
        mock_tenant.engine = "erpnext"
    
        # Mock database query result - need to mock select().join().where().where().all()
        from sqlalchemy import select
        from app.models.iam import Membership, Tenant
    
        mock_result = MagicMock()
        mock_result.all.return_value = [(mock_membership, mock_tenant)]
        mock_db.execute.return_value = mock_result
    
        try:
            response = client.get("/auth/me/memberships")
    
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_auth_api.py:188: AssertionError
________________________ TestCRMAPI.test_list_contacts _________________________

self = <tests.integration.test_crm_api.TestCRMAPI object at 0x10f8e6e90>
mock_adapter = <MagicMock name='erpnext_adapter' id='4560978336'>
mock_check_permission = <MagicMock name='check_permission' id='4560978672'>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': '12e253ff-9c60-447d-952b-dac1811096de', 'user_code': 'USER001', ...}

    @patch('app.routers.crm.check_permission')
    @patch('app.routers.crm.erpnext_adapter')
    def test_list_contacts(self, mock_adapter, mock_check_permission, mock_user):
        """Test listing contacts."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_token_payload] = lambda: mock_user
        app.dependency_overrides[get_db] = lambda: MagicMock()
    
        mock_check_permission.return_value = True
        mock_adapter.proxy_request.return_value = {
            "data": [
                {"name": "CONT-001", "first_name": "John", "last_name": "Doe"},
                {"name": "CONT-002", "first_name": "Jane", "last_name": "Smith"}
            ]
        }
    
        try:
            response = client.get(
                f"/api/tenants/{tenant_id}/erp/crm/contacts",
                headers={"Authorization": "Bearer test_token"}
            )
    
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_crm_api.py:49: AssertionError
________________________ TestCRMAPI.test_list_customers ________________________

self = <tests.integration.test_crm_api.TestCRMAPI object at 0x10f8e7890>
mock_adapter = <MagicMock name='erpnext_adapter' id='4560979344'>
mock_check_permission = <MagicMock name='check_permission' id='4560979680'>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': 'e8f8ca3d-cceb-49b0-a632-385856f4a1e8', 'user_code': 'USER001', ...}

    @patch('app.routers.crm.check_permission')
    @patch('app.routers.crm.erpnext_adapter')
    def test_list_customers(self, mock_adapter, mock_check_permission, mock_user):
        """Test listing customers."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_token_payload] = lambda: mock_user
        app.dependency_overrides[get_db] = lambda: MagicMock()
    
        mock_check_permission.return_value = True
        mock_adapter.proxy_request.return_value = {
            "data": [
                {"name": "CUST-001", "customer_name": "Acme Corp"}
            ]
        }
    
        try:
            response = client.get(
                f"/api/tenants/{tenant_id}/erp/crm/customers",
                headers={"Authorization": "Bearer test_token"}
            )
    
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_crm_api.py:74: AssertionError
_________________________ TestCRMAPI.test_create_lead __________________________

self = <tests.integration.test_crm_api.TestCRMAPI object at 0x10f9403e0>
mock_adapter = <MagicMock name='erpnext_adapter' id='4560980352'>
mock_check_permission = <MagicMock name='check_permission' id='4560980688'>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': '9c1fabd6-e85c-4509-92e9-bd28efc74660', 'user_code': 'USER001', ...}

    @patch('app.routers.crm.check_permission')
    @patch('app.routers.crm.erpnext_adapter')
    def test_create_lead(self, mock_adapter, mock_check_permission, mock_user):
        """Test creating a lead."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_token_payload] = lambda: mock_user
        app.dependency_overrides[get_db] = lambda: MagicMock()
    
        mock_check_permission.return_value = True
        mock_adapter.proxy_request.return_value = {
            "data": {
                "name": "LEAD-001",
                "lead_name": "New Lead",
                "status": "Open"
            }
        }
    
        try:
            response = client.post(
                f"/api/tenants/{tenant_id}/erp/crm/leads",
                json={
                    "lead_name": "New Lead",
                    "status": "Open",
                    "email": "lead@example.com"
                },
                headers={"Authorization": "Bearer test_token"}
            )
    
>           assert response.status_code in [200, 201]
E           assert 404 in [200, 201]
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_crm_api.py:106: AssertionError
___________________ TestERPModulesAPI.test_list_erp_modules ____________________

self = <tests.integration.test_erp_modules_api.TestERPModulesAPI object at 0x10f8e7750>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': 'cdc43188-e514-41b5-bc58-c2c00969be34', 'user_id': '56e0a769-b13e-47da-9991-58bfa942d48b'}

    def test_list_erp_modules(self, mock_user):
        """Test listing ERP modules."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_token_payload] = lambda: mock_user
        app.dependency_overrides[require_tenant_access] = lambda: tenant_id
        app.dependency_overrides[get_db] = lambda: MagicMock()
    
        # Mock database query
        mock_db = MagicMock()
>       from app.models.erp_modules import ERPModule
E       ImportError: cannot import name 'ERPModule' from 'app.models.erp_modules' (/Volumes/Stuff/Start Ups/MoranERP/Backend/app/models/erp_modules.py)

tests/integration/test_erp_modules_api.py:35: ImportError
________________________ TestHRAPI.test_list_employees _________________________

args = (<tests.integration.test_hr_api.TestHRAPI object at 0x10f968190>,)
keywargs = {'mock_user': {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': '39366f0e-1ce4-43ca-8314-ddba3f7444e0', 'user_code': 'USER001', ...}}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1423: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1405: in decoration_helper
    arg = exit_stack.enter_context(patching)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:530: in enter_context
    result = _enter(cm)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x10f94cec0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.routers.hr' from '/Volumes/Stuff/Start Ups/MoranERP/Backend/app/routers/hr.py'> does not have the attribute 'check_permission'

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1467: AttributeError
________________________ TestHRAPI.test_create_employee ________________________

args = (<tests.integration.test_hr_api.TestHRAPI object at 0x10f9682d0>,)
keywargs = {'mock_user': {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': 'c138902e-0c86-4c3b-ab80-1505f22b5d96', 'user_code': 'USER001', ...}}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1423: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1405: in decoration_helper
    arg = exit_stack.enter_context(patching)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:530: in enter_context
    result = _enter(cm)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x10f94cf70>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.routers.hr' from '/Volumes/Stuff/Start Ups/MoranERP/Backend/app/routers/hr.py'> does not have the attribute 'check_permission'

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1467: AttributeError
________________________ TestHRAPI.test_list_attendance ________________________

args = (<tests.integration.test_hr_api.TestHRAPI object at 0x10f941ba0>,)
keywargs = {'mock_user': {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': 'b4176adc-ee54-4b14-bb3d-ef2a1d04fd87', 'user_code': 'USER001', ...}}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1423: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1405: in decoration_helper
    arg = exit_stack.enter_context(patching)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:530: in enter_context
    result = _enter(cm)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x10f94d0d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.routers.hr' from '/Volumes/Stuff/Start Ups/MoranERP/Backend/app/routers/hr.py'> does not have the attribute 'check_permission'

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1467: AttributeError
_______________________ TestInventoryAPI.test_list_items _______________________

self = <tests.integration.test_inventory_api.TestInventoryAPI object at 0x10f968410>
mock_adapter = <MagicMock name='erpnext_adapter' id='4560102000'>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': 'f743b3d6-dff0-47e1-8c4a-b2320388e0f8', 'user_id': '06ebd9dd-5677-4702-9a87-0a26a2416548'}

    @patch('app.routers.inventory.erpnext_adapter')
    def test_list_items(self, mock_adapter, mock_user):
        """Test listing inventory items."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_user] = lambda: mock_user
        app.dependency_overrides[require_tenant_access] = lambda: tenant_id
        app.dependency_overrides[get_db] = lambda: MagicMock()
    
        # Mock adapter response - inventory router uses proxy_request which returns normalized response
        # The endpoint returns {"items": items or []}, and proxy_request returns {"data": [...]}
        mock_adapter.proxy_request.return_value = {
            "data": [
                {"item_code": "ITEM-001", "item_name": "Test Item 1"},
                {"item_code": "ITEM-002", "item_name": "Test Item 2"}
            ]
        }
    
        try:
            # The endpoint path is /api/tenants/{tenant_id}/erp/inventory/items
            response = client.get(
                f"/api/tenants/{tenant_id}/erp/inventory/items",
                headers={"Authorization": "Bearer test_token"}
            )
    
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_inventory_api.py:50: AssertionError
______________________ TestInventoryAPI.test_create_item _______________________

self = <tests.integration.test_inventory_api.TestInventoryAPI object at 0x10f968550>
mock_adapter = <MagicMock name='erpnext_adapter' id='4560095616'>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': '285018e4-80eb-40e2-93ec-1d13154b4af8', 'user_id': 'f0a4dc49-cb63-40b1-9d37-338ecb16244d'}

    @patch('app.routers.inventory.erpnext_adapter')
    def test_create_item(self, mock_adapter, mock_user):
        """Test creating inventory item."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_user] = lambda: mock_user
        app.dependency_overrides[require_tenant_access] = lambda: tenant_id
        app.dependency_overrides[get_db] = lambda: MagicMock()
    
        mock_adapter.proxy_request.return_value = {
            "data": {
                "item_code": "ITEM-001",
                "item_name": "New Item"
            }
        }
    
        try:
            response = client.post(
                f"/api/tenants/{tenant_id}/erp/inventory/items",
                json={
                    "item_code": "ITEM-001",
                    "item_name": "New Item",
                    "stock_uom": "Nos"
                },
                headers={"Authorization": "Bearer test_token"}
            )
    
>           assert response.status_code in [200, 201]
E           assert 404 in [200, 201]
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_inventory_api.py:84: AssertionError
________________________ TestInventoryAPI.test_get_item ________________________

self = <tests.integration.test_inventory_api.TestInventoryAPI object at 0x10f941e00>
mock_adapter = <MagicMock name='erpnext_adapter' id='4560101664'>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': '26d555d4-eae7-425a-a4b5-b1fbc0faf205', 'user_id': 'c660725f-778e-43d2-808e-571916f76861'}

    @patch('app.routers.inventory.erpnext_adapter')
    def test_get_item(self, mock_adapter, mock_user):
        """Test getting inventory item."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_user] = lambda: mock_user
        app.dependency_overrides[require_tenant_access] = lambda: tenant_id
        app.dependency_overrides[get_db] = lambda: MagicMock()
    
        mock_adapter.proxy_request.return_value = {
            "data": {
                "item_code": "ITEM-001",
                "item_name": "Test Item",
                "stock_uom": "Nos"
            }
        }
    
        try:
            response = client.get(
                f"/api/tenants/{tenant_id}/erp/inventory/items/ITEM-001",
                headers={"Authorization": "Bearer test_token"}
            )
    
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_inventory_api.py:110: AssertionError
____________________ TestInventoryAPI.test_list_warehouses _____________________

self = <tests.integration.test_inventory_api.TestInventoryAPI object at 0x10f941f30>
mock_adapter = <MagicMock name='erpnext_adapter' id='4560101328'>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': '0caffd32-d4bd-44af-b406-597edbe5c29d', 'user_id': 'c03884fc-7a09-4c1b-a7c3-57d29b98f1dd'}

    @patch('app.routers.inventory.erpnext_adapter')
    def test_list_warehouses(self, mock_adapter, mock_user):
        """Test listing warehouses."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_user] = lambda: mock_user
        app.dependency_overrides[require_tenant_access] = lambda: tenant_id
        app.dependency_overrides[get_db] = lambda: MagicMock()
    
        mock_adapter.proxy_request.return_value = {
            "data": [
                {"name": "Main Warehouse", "warehouse_name": "Main Warehouse"},
                {"name": "Branch Warehouse", "warehouse_name": "Branch Warehouse"}
            ]
        }
    
        try:
            response = client.get(
                f"/api/tenants/{tenant_id}/erp/inventory/warehouses",
                headers={"Authorization": "Bearer test_token"}
            )
    
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_inventory_api.py:135: AssertionError
___________________ TestInventoryAPI.test_get_stock_balance ____________________

self = <tests.integration.test_inventory_api.TestInventoryAPI object at 0x10f95b650>
mock_adapter = <MagicMock name='erpnext_adapter' id='4560101664'>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': 'd06b028d-45ec-4329-863c-66581a0d731e', 'user_id': '9fb924f9-fd47-4fe8-b655-fe0d5a90133e'}

    @patch('app.routers.inventory.erpnext_adapter')
    def test_get_stock_balance(self, mock_adapter, mock_user):
        """Test getting stock balance."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_user] = lambda: mock_user
        app.dependency_overrides[require_tenant_access] = lambda: tenant_id
        app.dependency_overrides[get_db] = lambda: MagicMock()
    
        mock_adapter.proxy_request.return_value = {"data": 100.0}
    
        try:
            response = client.get(
                f"/api/tenants/{tenant_id}/erp/inventory/stock-balance",
                params={"item_code": "ITEM-001", "warehouse": "Main Warehouse"},
                headers={"Authorization": "Bearer test_token"}
            )
    
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_inventory_api.py:156: AssertionError
__________________ TestManufacturingAPI.test_list_work_orders __________________

self = <tests.integration.test_manufacturing_api.TestManufacturingAPI object at 0x10f9687d0>
mock_adapter = <MagicMock name='erpnext_adapter' id='4560108048'>
mock_check_permission = <MagicMock name='check_permission' id='4559269776'>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': 'cf420655-430a-44ba-90bf-0a967c448ce4', 'user_code': 'USER001', ...}

    @patch('app.routers.manufacturing.check_permission')
    @patch('app.routers.manufacturing.erpnext_adapter')
    def test_list_work_orders(self, mock_adapter, mock_check_permission, mock_user):
        """Test listing work orders."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_token_payload] = lambda: mock_user
        app.dependency_overrides[get_db] = lambda: MagicMock()
    
        mock_check_permission.return_value = True
        mock_adapter.list_resource.return_value = {
            "data": [
                {"name": "WO-001", "production_item": "ITEM-001"}
            ]
        }
    
        try:
            response = client.get(
                f"/api/tenants/{tenant_id}/erp/manufacturing/work-orders",
                headers={"Authorization": "Bearer test_token"}
            )
    
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_manufacturing_api.py:84: AssertionError
________ TestPOSInvoiceIntegration.test_complete_invoice_creation_flow _________

self = <tests.integration.test_pos_invoice_integration.TestPOSInvoiceIntegration object at 0x10f969f90>
client = <starlette.testclient.TestClient object at 0x10ff8a430>
mock_erpnext_adapter = <AsyncMock id='4560978336'>

    @pytest.mark.asyncio
    async def test_complete_invoice_creation_flow(self, client, mock_erpnext_adapter):
        """Test complete invoice creation flow from request to GL entries"""
    
        # Mock the ERPNext adapter in the services
>       with patch('app.services.pos.pos_service_base.ERPNextAdapter', return_value=mock_erpnext_adapter), \
             patch('app.services.pos.vat_service.VATService.erpnext_adapter', mock_erpnext_adapter), \
             patch('app.services.pos.gl_distribution_service.GLDistributionService.erpnext_adapter', mock_erpnext_adapter):

tests/integration/test_pos_invoice_integration.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x110329180>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.pos.pos_service_base' from '/Volumes/Stuff/Start Ups/MoranERP/Backend/app/services/pos/pos_service_base.py'> does not have the attribute 'ERPNextAdapter'

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1467: AttributeError
__________ TestPOSInvoiceIntegration.test_vat_calculation_integration __________

self = <tests.integration.test_pos_invoice_integration.TestPOSInvoiceIntegration object at 0x10f969d10>
mock_erpnext_adapter = <AsyncMock id='4560101664'>

    @pytest.mark.asyncio
    async def test_vat_calculation_integration(self, mock_erpnext_adapter):
        """Test VAT calculation integration"""
        vat_service = VATService()
        vat_service.erpnext_adapter = mock_erpnext_adapter
    
        # Test VAT calculation
>       result = vat_service.calculate_vat_for_items([
            {
                'amount': Decimal('1000.00'),
                'vat_rate': Decimal('16.0'),
                'is_vatable': True
            }
        ])

tests/integration/test_pos_invoice_integration.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.pos.vat_service.VATService object at 0x10fb46510>
items = [{'amount': Decimal('1000.00'), 'is_vatable': True, 'vat_rate': Decimal('16.0')}]
is_vatable = True

    def calculate_vat_for_items(self, items: List[Dict[str, Any]], is_vatable: bool = True) -> Dict[str, Any]:
        """
        Calculate VAT for a list of items
    
        Args:
            items: List of items with amount, is_vatable flag, etc.
            is_vatable: Whether the entire invoice is subject to VAT
    
        Returns:
            Dict with total_amount, total_vat, items breakdown
        """
        if not is_vatable:
            # Non-VATable invoice - return zero VAT
            total_amount = sum(item.get('amount', 0) for item in items)
            items_breakdown = [
                {
                    **item,
                    'vat_amount': 0.0,
                    'net_amount': round(item.get('amount', 0), 2),
                    'vat_rate': 0.0
                }
                for item in items
            ]
            return {
                'total_amount': round(total_amount, 2),
                'total_base': round(total_amount, 2),
                'total_vat': 0.0,
                'items': items_breakdown,
                'vat_breakdown': [
                    {
                        "item_code": i.get("item_code"),
                        "net_amount": i.get("net_amount"),
                        "vat_amount": i.get("vat_amount"),
                        "vat_rate": i.get("vat_rate")
                    }
                    for i in items_breakdown
                ]
            }
    
        total_amount = 0.0
        total_vat = 0.0
        processed_items = []
    
        for item in items:
            amount = item.get('amount', 0)
            item_vat_rate = (item.get('vat_rate') or self.default_vat_rate) / 100  # Convert percentage to decimal
    
            # Calculate VAT for this item
            vat_amount = amount * item_vat_rate
            net_amount = amount  # Net amount is the full amount before VAT
>           total_amount += net_amount + vat_amount
E           TypeError: unsupported operand type(s) for +=: 'float' and 'decimal.Decimal'

app/services/pos/vat_service.py:74: TypeError
__________ TestPOSInvoiceIntegration.test_gl_distribution_integration __________

self = <tests.integration.test_pos_invoice_integration.TestPOSInvoiceIntegration object at 0x10f943100>
mock_erpnext_adapter = <AsyncMock id='4560109056'>

    @pytest.mark.asyncio
    async def test_gl_distribution_integration(self, mock_erpnext_adapter):
        """Test GL distribution integration"""
>       gl_service = GLDistributionService()
E       TypeError: GLDistributionService.__init__() missing 1 required positional argument: 'vat_service'

tests/integration/test_pos_invoice_integration.py:141: TypeError
____________ TestPOSInvoiceIntegration.test_pos_profile_validation _____________

self = <tests.integration.test_pos_invoice_integration.TestPOSInvoiceIntegration object at 0x10f943230>
client = <starlette.testclient.TestClient object at 0x110312a50>

    def test_pos_profile_validation(self, client):
        """Test POS profile validation in invoice creation"""
        # Test missing pos_profile_id
        invoice_request = {
            "customer": "TEST_CUSTOMER",
            "items": [{"item_code": "TEST_ITEM", "qty": 1, "rate": 1000.00}],
            "payments": [{"mode_of_payment": "Cash", "amount": 1160.00}]
            # Missing pos_profile_id
        }
    
        response = client.post(
            "/api/pos/invoice",
            json=invoice_request,
            headers={"X-Tenant-ID": "test-tenant"}
        )
    
        # Should fail with validation error
>       assert response.status_code == 422  # Validation error
E       assert 401 == 422
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/integration/test_pos_invoice_integration.py:200: AssertionError
___________ TestPOSInvoiceIntegration.test_payment_amount_validation ___________

self = <tests.integration.test_pos_invoice_integration.TestPOSInvoiceIntegration object at 0x10f9ad490>
client = <starlette.testclient.TestClient object at 0x110313150>

    def test_payment_amount_validation(self, client):
        """Test payment amount validation"""
        invoice_request = {
            "customer": "TEST_CUSTOMER",
            "items": [{"item_code": "TEST_ITEM", "qty": 1, "rate": 1000.00}],
            "payments": [
                {"mode_of_payment": "Cash", "amount": 500.00}  # Insufficient payment
            ],
            "pos_profile_id": "TEST_POS"
        }
    
        response = client.post(
            "/api/pos/invoice",
            json=invoice_request,
            headers={"X-Tenant-ID": "test-tenant"}
        )
    
        # Should fail with payment validation error
>       assert response.status_code in [400, 422]
E       assert 401 in [400, 422]
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/integration/test_pos_invoice_integration.py:220: AssertionError
___________ TestPOSInvoiceIntegration.test_offline_transaction_queue ___________

self = <tests.integration.test_pos_invoice_integration.TestPOSInvoiceIntegration object at 0x10f96d9d0>
mock_erpnext_adapter = <AsyncMock id='4560983040'>

    @pytest.mark.asyncio
    async def test_offline_transaction_queue(self, mock_erpnext_adapter):
        """Test offline transaction queuing"""
        from app.services.pos.offline_service import OfflineService
    
        offline_service = OfflineService()
        offline_service.erpnext_adapter = mock_erpnext_adapter
    
        # Queue a transaction
        transaction_id = await offline_service.queue_transaction(
            tenant_id="test-tenant",
            transaction_type="invoice",
            data={"test": "data"},
            priority=2
        )
    
        assert transaction_id is not None
    
        # Retrieve pending transactions
        pending = await offline_service.get_pending_transactions("test-tenant")
    
>       assert len(pending) >= 1
E       assert 0 >= 1
E        +  where 0 = len([])

tests/integration/test_pos_invoice_integration.py:243: AssertionError
______________ TestPOSInvoiceIntegration.test_api_response_format ______________

self = <tests.integration.test_pos_invoice_integration.TestPOSInvoiceIntegration object at 0x10f96dae0>
client = <starlette.testclient.TestClient object at 0x11031d470>

    def test_api_response_format(self, client):
        """Test API response format consistency"""
        # Test successful response structure
        response = client.get("/api/pos/items", headers={"X-Tenant-ID": "test-tenant"})
    
        # Should return proper JSON structure even if empty
>       assert response.status_code in [200, 404]  # OK or Not Found for empty data
E       assert 401 in [200, 404]
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests/integration/test_pos_invoice_integration.py:252: AssertionError
______________________ TestProjectsAPI.test_list_projects ______________________

self = <tests.integration.test_projects_api.TestProjectsAPI object at 0x10f96a0d0>
mock_adapter = <MagicMock name='erpnext_adapter' id='4560109056'>
mock_check_permission = <MagicMock name='check_permission' id='4560102000'>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': '10f153b8-fedd-45a9-9141-5fc61e3eb775', 'user_code': 'USER001', ...}

    @patch('app.routers.projects.check_permission')
    @patch('app.routers.projects.erpnext_adapter')
    def test_list_projects(self, mock_adapter, mock_check_permission, mock_user):
        """Test listing projects."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_token_payload] = lambda: mock_user
        app.dependency_overrides[get_db] = lambda: MagicMock()
    
        mock_check_permission.return_value = True
        mock_adapter.list_resource.return_value = {
            "data": [
                {"name": "PROJ-001", "project_name": "Project Alpha"},
                {"name": "PROJ-002", "project_name": "Project Beta"}
            ]
        }
    
        try:
            response = client.get(
                f"/api/tenants/{tenant_id}/erp/projects/projects",
                headers={"Authorization": "Bearer test_token"}
            )
    
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_projects_api.py:49: AssertionError
_______________________ TestProjectsAPI.test_list_tasks ________________________

self = <tests.integration.test_projects_api.TestProjectsAPI object at 0x10f96a210>
mock_adapter = <MagicMock name='erpnext_adapter' id='4560100656'>
mock_check_permission = <MagicMock name='check_permission' id='4560108048'>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': '6e262ed3-7248-4b4c-bd63-8eb4f3bbcb78', 'user_code': 'USER001', ...}

    @patch('app.routers.projects.check_permission')
    @patch('app.routers.projects.erpnext_adapter')
    def test_list_tasks(self, mock_adapter, mock_check_permission, mock_user):
        """Test listing tasks."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_token_payload] = lambda: mock_user
        app.dependency_overrides[get_db] = lambda: MagicMock()
    
        mock_check_permission.return_value = True
        mock_adapter.list_resource.return_value = {
            "data": [
                {"name": "TASK-001", "subject": "Task 1", "project": "PROJ-001"}
            ]
        }
    
        try:
            response = client.get(
                f"/api/tenants/{tenant_id}/erp/projects/tasks",
                headers={"Authorization": "Bearer test_token"}
            )
    
>           assert response.status_code == 200
E           assert 404 == 200
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_projects_api.py:74: AssertionError
_____________________ TestProjectsAPI.test_create_project ______________________

self = <tests.integration.test_projects_api.TestProjectsAPI object at 0x10f943360>
mock_adapter = <MagicMock name='erpnext_adapter' id='4560097632'>
mock_check_permission = <MagicMock name='check_permission' id='4560103008'>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': '6e617662-28d6-43e3-8058-8efe0928adc9', 'user_code': 'USER001', ...}

    @patch('app.routers.projects.check_permission')
    @patch('app.routers.projects.erpnext_adapter')
    def test_create_project(self, mock_adapter, mock_check_permission, mock_user):
        """Test creating project."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_token_payload] = lambda: mock_user
        app.dependency_overrides[get_db] = lambda: MagicMock()
    
        mock_check_permission.return_value = True
        mock_adapter.create_resource.return_value = {
            "data": {
                "name": "PROJ-001",
                "project_name": "New Project"
            }
        }
    
        try:
            response = client.post(
                f"/api/tenants/{tenant_id}/erp/projects/projects",
                json={
                    "project_name": "New Project",
                    "status": "Open"
                },
                headers={"Authorization": "Bearer test_token"}
            )
    
>           assert response.status_code in [200, 201]
E           assert 404 in [200, 201]
E            +  where 404 = <Response [404 Not Found]>.status_code

tests/integration/test_projects_api.py:104: AssertionError
__________________ TestPurchasesAPI.test_list_purchase_orders __________________
  + Exception Group Traceback (most recent call last):
  |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/_utils.py", line 76, in collapse_excgroups
  |     yield
  |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/base.py", line 186, in __call__
  |     async with anyio.create_task_group() as task_group:
  |                ~~~~~~~~~~~~~~~~~~~~~~~^^
  |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/anyio/_backends/_asyncio.py", line 772, in __aexit__
  |     raise BaseExceptionGroup(
  |         "unhandled errors in a TaskGroup", self._exceptions
  |     ) from None
  | ExceptionGroup: unhandled errors in a TaskGroup (1 sub-exception)
  +-+---------------- 1 ----------------
    | Traceback (most recent call last):
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/_pytest/runner.py", line 341, in from_call
    |     result: TResult | None = func()
    |                              ~~~~^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/_pytest/runner.py", line 242, in <lambda>
    |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
    |             ~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_hooks.py", line 512, in __call__
    |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
    |            ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_manager.py", line 120, in _hookexec
    |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    |            ~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_callers.py", line 167, in _multicall
    |     raise exception
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |     ~~~~~~~~~~~~~~^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/_pytest/threadexception.py", line 92, in pytest_runtest_call
    |     yield from thread_exception_runtest_hook()
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/_pytest/threadexception.py", line 68, in thread_exception_runtest_hook
    |     yield
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |     ~~~~~~~~~~~~~~^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/_pytest/unraisableexception.py", line 95, in pytest_runtest_call
    |     yield from unraisable_exception_runtest_hook()
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/_pytest/unraisableexception.py", line 70, in unraisable_exception_runtest_hook
    |     yield
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |     ~~~~~~~~~~~~~~^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/_pytest/logging.py", line 846, in pytest_runtest_call
    |     yield from self._runtest_for(item, "call")
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/_pytest/logging.py", line 829, in _runtest_for
    |     yield
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |     ~~~~~~~~~~~~~~^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_callers.py", line 53, in run_old_style_hookwrapper
    |     return result.get_result()
    |            ~~~~~~~~~~~~~~~~~^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_result.py", line 103, in get_result
    |     raise exc.with_traceback(tb)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_callers.py", line 38, in run_old_style_hookwrapper
    |     res = yield
    |           ^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |     ~~~~~~~~~~~~~~^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/_pytest/capture.py", line 880, in pytest_runtest_call
    |     return (yield)
    |             ^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |     ~~~~~~~~~~~~~~^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/_pytest/skipping.py", line 257, in pytest_runtest_call
    |     return (yield)
    |             ^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_callers.py", line 121, in _multicall
    |     res = hook_impl.function(*args)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/_pytest/runner.py", line 174, in pytest_runtest_call
    |     item.runtest()
    |     ~~~~~~~~~~~~^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/_pytest/python.py", line 1627, in runtest
    |     self.ihook.pytest_pyfunc_call(pyfuncitem=self)
    |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_hooks.py", line 512, in __call__
    |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
    |            ~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_manager.py", line 120, in _hookexec
    |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    |            ~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_callers.py", line 167, in _multicall
    |     raise exception
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |     ~~~~~~~~~~~~~~^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_callers.py", line 53, in run_old_style_hookwrapper
    |     return result.get_result()
    |            ~~~~~~~~~~~~~~~~~^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_result.py", line 103, in get_result
    |     raise exc.with_traceback(tb)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_callers.py", line 38, in run_old_style_hookwrapper
    |     res = yield
    |           ^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pluggy/_callers.py", line 121, in _multicall
    |     res = hook_impl.function(*args)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/_pytest/python.py", line 159, in pytest_pyfunc_call
    |     result = testfunction(**testargs)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py", line 1426, in patched
    |     return func(*newargs, **newkeywargs)
    |   File "/Volumes/Stuff/Start Ups/MoranERP/Backend/tests/integration/test_purchases_api.py", line 47, in test_list_purchase_orders
    |     response = client.get(
    |         f"/purchases/orders",
    |         headers={"Authorization": "Bearer test_token", "X-Tenant-ID": tenant_id}
    |     )
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/testclient.py", line 514, in get
    |     return super().get(
    |            ~~~~~~~~~~~^
    |         url,
    |         ^^^^
    |     ...<6 lines>...
    |         extensions=extensions,
    |         ^^^^^^^^^^^^^^^^^^^^^^
    |     )
    |     ^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py", line 1053, in get
    |     return self.request(
    |            ~~~~~~~~~~~~^
    |         "GET",
    |         ^^^^^^
    |     ...<7 lines>...
    |         extensions=extensions,
    |         ^^^^^^^^^^^^^^^^^^^^^^
    |     )
    |     ^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/testclient.py", line 484, in request
    |     return super().request(
    |            ~~~~~~~~~~~~~~~^
    |         method,
    |         ^^^^^^^
    |     ...<11 lines>...
    |         extensions=extensions,
    |         ^^^^^^^^^^^^^^^^^^^^^^
    |     )
    |     ^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py", line 825, in request
    |     return self.send(request, auth=auth, follow_redirects=follow_redirects)
    |            ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py", line 914, in send
    |     response = self._send_handling_auth(
    |         request,
    |     ...<2 lines>...
    |         history=[],
    |     )
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py", line 942, in _send_handling_auth
    |     response = self._send_handling_redirects(
    |         request,
    |         follow_redirects=follow_redirects,
    |         history=history,
    |     )
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py", line 979, in _send_handling_redirects
    |     response = self._send_single_request(request)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py", line 1014, in _send_single_request
    |     response = transport.handle_request(request)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/testclient.py", line 377, in handle_request
    |     raise exc
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/testclient.py", line 374, in handle_request
    |     portal.call(self.app, scope, receive, send)
    |     ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/anyio/from_thread.py", line 291, in call
    |     return cast(T_Retval, self.start_task_soon(func, *args).result())
    |                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/concurrent/futures/_base.py", line 456, in result
    |     return self.__get_result()
    |            ~~~~~~~~~~~~~~~~~^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/concurrent/futures/_base.py", line 401, in __get_result
    |     raise self._exception
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/anyio/from_thread.py", line 222, in _call_func
    |     retval = await retval_or_awaitable
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/fastapi/applications.py", line 1054, in __call__
    |     await super().__call__(scope, receive, send)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/applications.py", line 113, in __call__
    |     await self.middleware_stack(scope, receive, send)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/errors.py", line 187, in __call__
    |     raise exc
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/errors.py", line 165, in __call__
    |     await self.app(scope, receive, _send)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/base.py", line 185, in __call__
    |     with collapse_excgroups():
    |          ~~~~~~~~~~~~~~~~~~^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py", line 162, in __exit__
    |     self.gen.throw(value)
    |     ~~~~~~~~~~~~~~^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/_utils.py", line 82, in collapse_excgroups
    |     raise exc
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/base.py", line 187, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/Volumes/Stuff/Start Ups/MoranERP/Backend/app/middleware/pos_cache_middleware.py", line 190, in dispatch
    |     response = await call_next(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/base.py", line 163, in call_next
    |     raise app_exc
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/base.py", line 149, in coro
    |     await self.app(scope, receive_or_disconnect, send_no_error)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/base.py", line 185, in __call__
    |     with collapse_excgroups():
    |          ~~~~~~~~~~~~~~~~~~^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py", line 162, in __exit__
    |     self.gen.throw(value)
    |     ~~~~~~~~~~~~~~^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/_utils.py", line 82, in collapse_excgroups
    |     raise exc
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/base.py", line 187, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/Volumes/Stuff/Start Ups/MoranERP/Backend/app/middleware/pos_cache_middleware.py", line 35, in dispatch
    |     return await call_next(request)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/base.py", line 163, in call_next
    |     raise app_exc
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/base.py", line 149, in coro
    |     await self.app(scope, receive_or_disconnect, send_no_error)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/cors.py", line 85, in __call__
    |     await self.app(scope, receive, send)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/exceptions.py", line 62, in __call__
    |     await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    |     raise exc
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    |     await app(scope, receive, sender)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/routing.py", line 715, in __call__
    |     await self.middleware_stack(scope, receive, send)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/routing.py", line 735, in app
    |     await route.handle(scope, receive, send)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/routing.py", line 288, in handle
    |     await self.app(scope, receive, send)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/routing.py", line 76, in app
    |     await wrap_app_handling_exceptions(app, request)(scope, receive, send)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    |     raise exc
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    |     await app(scope, receive, sender)
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/routing.py", line 73, in app
    |     response = await f(request)
    |                ^^^^^^^^^^^^^^^^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/fastapi/routing.py", line 301, in app
    |     raw_response = await run_endpoint_function(
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |     ...<3 lines>...
    |     )
    |     ^
    |   File "/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/fastapi/routing.py", line 212, in run_endpoint_function
    |     return await dependant.call(**values)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "/Volumes/Stuff/Start Ups/MoranERP/Backend/app/routers/purchases.py", line 214, in list_purchase_orders
    |     result = await service.list_purchase_orders(tenant_id, filters, limit)
    |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | TypeError: TestPurchasesAPI.test_list_purchase_orders.<locals>.async_list() takes 0 positional arguments but 3 were given
    +------------------------------------

During handling of the above exception, another exception occurred:

self = <tests.integration.test_purchases_api.TestPurchasesAPI object at 0x10f96a990>
mock_get_service = <MagicMock name='get_purchase_service' id='4560102000'>
mock_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': '8bf64916-bdd3-44e3-9ae5-8bb2ac10babc', 'user_id': 'eb140262-fd81-4652-9992-a3328a9b245c'}

    @patch('app.routers.purchases.get_purchase_service')
    def test_list_purchase_orders(self, mock_get_service, mock_user):
        """Test listing purchase orders."""
        tenant_id = mock_user['tenant_id']
        app.dependency_overrides[get_current_user] = lambda: mock_user
        app.dependency_overrides[require_tenant_access] = lambda: tenant_id
        app.dependency_overrides[get_db] = lambda: MagicMock()
        app.dependency_overrides[get_tenant_engine] = lambda: "erpnext"
    
        # Mock purchase service - list_purchase_orders is async
        mock_service = MagicMock()
        async def async_list():
            return [
                {"name": "PO-001", "supplier": "Supplier A"},
                {"name": "PO-002", "supplier": "Supplier B"}
            ]
        mock_service.list_purchase_orders = async_list
        mock_get_service.return_value = mock_service
    
        try:
>           response = client.get(
                f"/purchases/orders",
                headers={"Authorization": "Bearer test_token", "X-Tenant-ID": tenant_id}
            )

tests/integration/test_purchases_api.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/testclient.py:514: in get
    return super().get(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:1053: in get
    return self.request(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/testclient.py:484: in request
    return super().request(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/testclient.py:377: in handle_request
    raise exc
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/testclient.py:374: in handle_request
    portal.call(self.app, scope, receive, send)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/anyio/from_thread.py:291: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/concurrent/futures/_base.py:456: in result
    return self.__get_result()
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/anyio/from_thread.py:222: in _call_func
    retval = await retval_or_awaitable
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/fastapi/applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/errors.py:187: in __call__
    raise exc
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/errors.py:165: in __call__
    await self.app(scope, receive, _send)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/base.py:185: in __call__
    with collapse_excgroups():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:162: in __exit__
    self.gen.throw(value)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/_utils.py:82: in collapse_excgroups
    raise exc
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/base.py:187: in __call__
    response = await self.dispatch_func(request, call_next)
app/middleware/pos_cache_middleware.py:190: in dispatch
    response = await call_next(request)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/base.py:163: in call_next
    raise app_exc
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/base.py:149: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/base.py:185: in __call__
    with collapse_excgroups():
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/contextlib.py:162: in __exit__
    self.gen.throw(value)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/_utils.py:82: in collapse_excgroups
    raise exc
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/base.py:187: in __call__
    response = await self.dispatch_func(request, call_next)
app/middleware/pos_cache_middleware.py:35: in dispatch
    return await call_next(request)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/base.py:163: in call_next
    raise app_exc
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/base.py:149: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/cors.py:85: in __call__
    await self.app(scope, receive, send)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/middleware/exceptions.py:62: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/routing.py:715: in __call__
    await self.middleware_stack(scope, receive, send)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/routing.py:735: in app
    await route.handle(scope, receive, send)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/routing.py:288: in handle
    await self.app(scope, receive, send)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/routing.py:76: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/starlette/routing.py:73: in app
    response = await f(request)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/fastapi/routing.py:301: in app
    raw_response = await run_endpoint_function(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/fastapi/routing.py:212: in run_endpoint_function
    return await dependant.call(**values)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

status = None, supplier_id = None, from_date = None, to_date = None, limit = 50
tenant_id = '8bf64916-bdd3-44e3-9ae5-8bb2ac10babc'
current_user = {'email': 'test@example.com', 'roles': ['ADMIN'], 'tenant_id': '8bf64916-bdd3-44e3-9ae5-8bb2ac10babc', 'user_id': 'eb140262-fd81-4652-9992-a3328a9b245c'}
engine = 'erpnext'

    @router.get("/orders")
    async def list_purchase_orders(
        status: Optional[str] = None,
        supplier_id: Optional[str] = None,
        from_date: Optional[str] = None,
        to_date: Optional[str] = None,
        limit: int = Query(50, le=200),
        tenant_id: str = Depends(require_tenant_access),
        current_user: dict = Depends(get_current_user),
        engine: str = Depends(get_tenant_engine)
    ):
        """List purchase orders - platform agnostic"""
        service = get_purchase_service(engine)
    
        filters = {}
        if status:
            filters["status"] = status
        if supplier_id:
            filters["supplier_id"] = supplier_id
        if from_date:
            filters["from_date"] = from_date
        if to_date:
            filters["to_date"] = to_date
    
>       result = await service.list_purchase_orders(tenant_id, filters, limit)
E       TypeError: TestPurchasesAPI.test_list_purchase_orders.<locals>.async_list() takes 0 positional arguments but 3 were given

app/routers/purchases.py:214: TypeError
______________________________ test_health_check _______________________________

async_client = <httpx.AsyncClient object at 0x110099010>

    @pytest.mark.asyncio
    async def test_health_check(async_client):
>       response = await async_client.get("/health")

tests/test_health.py:5: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:1768: in get
    return await self.request(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:1540: in request
    return await self.send(request, auth=auth, follow_redirects=follow_redirects)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:1629: in send
    response = await self._send_handling_auth(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:1657: in _send_handling_auth
    response = await self._send_handling_redirects(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:1694: in _send_handling_redirects
    response = await self._send_single_request(request)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:1730: in _send_single_request
    response = await transport.handle_async_request(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.ASGITransport object at 0x110098ec0>
request = <Request('GET', 'http://test/health')>

    async def handle_async_request(
        self,
        request: Request,
    ) -> Response:
        assert isinstance(request.stream, AsyncByteStream)
    
        # ASGI scope.
        scope = {
            "type": "http",
            "asgi": {"version": "3.0"},
            "http_version": "1.1",
            "method": request.method,
            "headers": [(k.lower(), v) for (k, v) in request.headers.raw],
            "scheme": request.url.scheme,
            "path": request.url.path,
            "raw_path": request.url.raw_path.split(b"?")[0],
            "query_string": request.url.query,
            "server": (request.url.host, request.url.port),
            "client": self.client,
            "root_path": self.root_path,
        }
    
        # Request.
        request_body_chunks = request.stream.__aiter__()
        request_complete = False
    
        # Response.
        status_code = None
        response_headers = None
        body_parts = []
        response_started = False
        response_complete = create_event()
    
        # ASGI callables.
    
        async def receive() -> dict[str, typing.Any]:
            nonlocal request_complete
    
            if request_complete:
                await response_complete.wait()
                return {"type": "http.disconnect"}
    
            try:
                body = await request_body_chunks.__anext__()
            except StopAsyncIteration:
                request_complete = True
                return {"type": "http.request", "body": b"", "more_body": False}
            return {"type": "http.request", "body": body, "more_body": True}
    
        async def send(message: typing.MutableMapping[str, typing.Any]) -> None:
            nonlocal status_code, response_headers, response_started
    
            if message["type"] == "http.response.start":
                assert not response_started
    
                status_code = message["status"]
                response_headers = message.get("headers", [])
                response_started = True
    
            elif message["type"] == "http.response.body":
                assert not response_complete.is_set()
                body = message.get("body", b"")
                more_body = message.get("more_body", False)
    
                if body and request.method != "HEAD":
                    body_parts.append(body)
    
                if not more_body:
                    response_complete.set()
    
        try:
>           await self.app(scope, receive, send)
E           TypeError: 'module' object is not callable

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_transports/asgi.py:170: TypeError
__________________________________ test_root ___________________________________

async_client = <httpx.AsyncClient object at 0x110395590>

    @pytest.mark.asyncio
    async def test_root(async_client):
>       response = await async_client.get("/")

tests/test_health.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:1768: in get
    return await self.request(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:1540: in request
    return await self.send(request, auth=auth, follow_redirects=follow_redirects)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:1629: in send
    response = await self._send_handling_auth(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:1657: in _send_handling_auth
    response = await self._send_handling_redirects(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:1694: in _send_handling_redirects
    response = await self._send_single_request(request)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_client.py:1730: in _send_single_request
    response = await transport.handle_async_request(request)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.ASGITransport object at 0x110395bd0>
request = <Request('GET', 'http://test/')>

    async def handle_async_request(
        self,
        request: Request,
    ) -> Response:
        assert isinstance(request.stream, AsyncByteStream)
    
        # ASGI scope.
        scope = {
            "type": "http",
            "asgi": {"version": "3.0"},
            "http_version": "1.1",
            "method": request.method,
            "headers": [(k.lower(), v) for (k, v) in request.headers.raw],
            "scheme": request.url.scheme,
            "path": request.url.path,
            "raw_path": request.url.raw_path.split(b"?")[0],
            "query_string": request.url.query,
            "server": (request.url.host, request.url.port),
            "client": self.client,
            "root_path": self.root_path,
        }
    
        # Request.
        request_body_chunks = request.stream.__aiter__()
        request_complete = False
    
        # Response.
        status_code = None
        response_headers = None
        body_parts = []
        response_started = False
        response_complete = create_event()
    
        # ASGI callables.
    
        async def receive() -> dict[str, typing.Any]:
            nonlocal request_complete
    
            if request_complete:
                await response_complete.wait()
                return {"type": "http.disconnect"}
    
            try:
                body = await request_body_chunks.__anext__()
            except StopAsyncIteration:
                request_complete = True
                return {"type": "http.request", "body": b"", "more_body": False}
            return {"type": "http.request", "body": body, "more_body": True}
    
        async def send(message: typing.MutableMapping[str, typing.Any]) -> None:
            nonlocal status_code, response_headers, response_started
    
            if message["type"] == "http.response.start":
                assert not response_started
    
                status_code = message["status"]
                response_headers = message.get("headers", [])
                response_started = True
    
            elif message["type"] == "http.response.body":
                assert not response_complete.is_set()
                body = message.get("body", b"")
                more_body = message.get("more_body", False)
    
                if body and request.method != "HEAD":
                    body_parts.append(body)
    
                if not more_body:
                    response_complete.set()
    
        try:
>           await self.app(scope, receive, send)
E           TypeError: 'module' object is not callable

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/httpx/_transports/asgi.py:170: TypeError
________ TestRequireTenantAccess.test_require_tenant_access_super_admin ________

self = <test_dependencies_auth.TestRequireTenantAccess object at 0x10fa4d590>

    @pytest.mark.asyncio
    async def test_require_tenant_access_super_admin(self):
        """Test tenant access for super admin."""
        payload = {
            "is_super_admin": True,
            "tenant_id": None
        }
    
>       result = await require_tenant_access(payload=payload)

tests/unit/test_dependencies_auth.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/dependencies/auth.py:92: in require_tenant_access
    tenant_uuid = uuid.UUID(resolved_tenant_id)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'uuid.UUID' object has no attribute 'int'") raised in repr()] UUID object at 0x1105d6f50>
hex = Header(None), bytes = None, bytes_le = None, fields = None, int = None
version = None

    def __init__(self, hex=None, bytes=None, bytes_le=None, fields=None,
                       int=None, version=None,
                       *, is_safe=SafeUUID.unknown):
        r"""Create a UUID from either a string of 32 hexadecimal digits,
        a string of 16 bytes as the 'bytes' argument, a string of 16 bytes
        in little-endian order as the 'bytes_le' argument, a tuple of six
        integers (32-bit time_low, 16-bit time_mid, 16-bit time_hi_version,
        8-bit clock_seq_hi_variant, 8-bit clock_seq_low, 48-bit node) as
        the 'fields' argument, or a single 128-bit integer as the 'int'
        argument.  When a string of hex digits is given, curly braces,
        hyphens, and a URN prefix are all optional.  For example, these
        expressions all yield the same UUID:
    
        UUID('{12345678-1234-5678-1234-567812345678}')
        UUID('12345678123456781234567812345678')
        UUID('urn:uuid:12345678-1234-5678-1234-567812345678')
        UUID(bytes='\x12\x34\x56\x78'*4)
        UUID(bytes_le='\x78\x56\x34\x12\x34\x12\x78\x56' +
                      '\x12\x34\x56\x78\x12\x34\x56\x78')
        UUID(fields=(0x12345678, 0x1234, 0x5678, 0x12, 0x34, 0x567812345678))
        UUID(int=0x12345678123456781234567812345678)
    
        Exactly one of 'hex', 'bytes', 'bytes_le', 'fields', or 'int' must
        be given.  The 'version' argument is optional; if given, the resulting
        UUID will have its variant and version set according to RFC 4122,
        overriding the given 'hex', 'bytes', 'bytes_le', 'fields', or 'int'.
    
        is_safe is an enum exposed as an attribute on the instance.  It
        indicates whether the UUID has been generated in a way that is safe
        for multiprocessing applications, via uuid_generate_time_safe(3).
        """
    
        if [hex, bytes, bytes_le, fields, int].count(None) != 4:
            raise TypeError('one of the hex, bytes, bytes_le, fields, '
                            'or int arguments must be given')
        if hex is not None:
>           hex = hex.replace('urn:', '').replace('uuid:', '')
E           AttributeError: 'Header' object has no attribute 'replace'

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/uuid.py:178: AttributeError
_________________ TestERPNextClientAdapter.test_login_success __________________

self = <test_erpnext_client.TestERPNextClientAdapter object at 0x10faac050>
mock_session_class = <MagicMock name='Session' id='4560983712'>
adapter = <app.services.erpnext_client.ERPNextClientAdapter object at 0x1161e5010>

    @patch('app.services.erpnext_client.requests.Session')
    def test_login_success(self, mock_session_class, adapter):
        """Test successful login."""
        mock_session = MagicMock()
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.cookies = {"sid": "test-session-id"}
        mock_session.post.return_value = mock_response
        mock_session_class.return_value = mock_session
        adapter.session = mock_session
    
        result = adapter._login("test-tenant")
>       assert result is True
E       assert (True, None) is True

tests/unit/test_erpnext_client.py:56: AssertionError
_________________ TestERPNextClientAdapter.test_login_failure __________________

self = <test_erpnext_client.TestERPNextClientAdapter object at 0x10f96f020>
mock_session_class = <MagicMock name='Session' id='4560992112'>
adapter = <app.services.erpnext_client.ERPNextClientAdapter object at 0x110333460>

    @patch('app.services.erpnext_client.requests.Session')
    def test_login_failure(self, mock_session_class, adapter):
        """Test failed login."""
        mock_session = MagicMock()
        mock_response = MagicMock()
        mock_response.status_code = 401
        mock_response.text = "Invalid credentials"
        mock_session.post.return_value = mock_response
        mock_session_class.return_value = mock_session
        adapter.session = mock_session
    
        result = adapter._login("test-tenant")
>       assert result is False
E       AssertionError: assert (False, 'ERPNext login failed (HTTP 401)') is False

tests/unit/test_erpnext_client.py:73: AssertionError
----------------------------- Captured stdout call -----------------------------
ERPNext Login Failed for test-tenant: ERPNext login failed (HTTP 401)
________________ TestERPNextClientAdapter.test_login_exception _________________

self = <test_erpnext_client.TestERPNextClientAdapter object at 0x10f96f130>
mock_session_class = <MagicMock name='Session' id='4560988080'>
adapter = <app.services.erpnext_client.ERPNextClientAdapter object at 0x1103329c0>

    @patch('app.services.erpnext_client.requests.Session')
    def test_login_exception(self, mock_session_class, adapter):
        """Test login with exception."""
        mock_session = MagicMock()
        mock_session.post.side_effect = Exception("Connection error")
        mock_session_class.return_value = mock_session
        adapter.session = mock_session
    
        result = adapter._login("test-tenant")
>       assert result is False
E       AssertionError: assert (False, 'Unexpected error connecting to ERPNext: Connection error') is False

tests/unit/test_erpnext_client.py:84: AssertionError
----------------------------- Captured stdout call -----------------------------
ERPNext Login Exception for test-tenant: Connection error
_____________ TestERPNextClientAdapter.test_proxy_request_success ______________

self = <test_erpnext_client.TestERPNextClientAdapter object at 0x10f937a50>
mock_login = <MagicMock name='_login' id='4560987744'>
adapter = <app.services.erpnext_client.ERPNextClientAdapter object at 0x1161a8e50>

    @patch.object(ERPNextClientAdapter, '_login')
    def test_proxy_request_success(self, mock_login, adapter):
        """Test successful proxy request."""
        mock_login.return_value = True
        adapter.cookie_jar = {"sid": "test-session-id"}
        adapter._current_tenant = "moran.localhost"
    
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"message": {"data": "test"}}
        adapter.session.request = MagicMock(return_value=mock_response)
    
>       result = adapter.proxy_request("test-tenant", "resource/Item", method="GET")

tests/unit/test_erpnext_client.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.erpnext_client.ERPNextClientAdapter object at 0x1161a8e50>
tenant_id = 'test-tenant', path = 'resource/Item', method = 'GET', params = None
json_data = None

    def proxy_request(self, tenant_id: str, path: str, method: str = "GET", params: dict = None, json_data: dict = None):
        """
        Proxies a request to the ERPNext/Frappe API using Cookie Auth with structured error handling.
    
        Args:
            tenant_id: Tenant identifier (site name)
            path: API endpoint path
            method: HTTP method
            params: Query parameters
            json_data: JSON request body
        """
        site_name = self._resolve_site_name(tenant_id)
    
        # Re-login if tenant changed
        if not self.cookie_jar or self._current_tenant != site_name:
>           login_success, login_error = self._login(site_name)
E           TypeError: cannot unpack non-iterable bool object

app/services/erpnext_client.py:152: TypeError
__________ TestERPNextClientAdapter.test_proxy_request_error_handling __________

self = <test_erpnext_client.TestERPNextClientAdapter object at 0x10f937b50>
mock_login = <MagicMock name='_login' id='4564030800'>
adapter = <app.services.erpnext_client.ERPNextClientAdapter object at 0x1161a9050>

    @patch.object(ERPNextClientAdapter, '_login')
    def test_proxy_request_error_handling(self, mock_login, adapter):
        """Test proxy request error handling."""
        mock_login.return_value = True
        adapter.cookie_jar = {"sid": "test-session-id"}
        adapter._current_tenant = "moran.localhost"
    
        mock_response = MagicMock()
        mock_response.status_code = 400
        mock_response.json.return_value = {"message": "Error message"}
        mock_response.text = "Error message"
        adapter.session.request = MagicMock(return_value=mock_response)
    
        with pytest.raises(HTTPException) as exc_info:
>           adapter.proxy_request("test-tenant", "resource/Item", method="GET")

tests/unit/test_erpnext_client.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.erpnext_client.ERPNextClientAdapter object at 0x1161a9050>
tenant_id = 'test-tenant', path = 'resource/Item', method = 'GET', params = None
json_data = None

    def proxy_request(self, tenant_id: str, path: str, method: str = "GET", params: dict = None, json_data: dict = None):
        """
        Proxies a request to the ERPNext/Frappe API using Cookie Auth with structured error handling.
    
        Args:
            tenant_id: Tenant identifier (site name)
            path: API endpoint path
            method: HTTP method
            params: Query parameters
            json_data: JSON request body
        """
        site_name = self._resolve_site_name(tenant_id)
    
        # Re-login if tenant changed
        if not self.cookie_jar or self._current_tenant != site_name:
>           login_success, login_error = self._login(site_name)
E           TypeError: cannot unpack non-iterable bool object

app/services/erpnext_client.py:152: TypeError
__________ TestERPNextClientAdapter.test_proxy_request_non_json_error __________

self = <test_erpnext_client.TestERPNextClientAdapter object at 0x10fa489b0>
mock_login = <MagicMock name='_login' id='4560992784'>
adapter = <app.services.erpnext_client.ERPNextClientAdapter object at 0x11032ff20>

    @patch.object(ERPNextClientAdapter, '_login')
    def test_proxy_request_non_json_error(self, mock_login, adapter):
        """Test proxy request with non-JSON error response."""
        mock_login.return_value = True
        adapter.cookie_jar = {"sid": "test-session-id"}
        adapter._current_tenant = "moran.localhost"
    
        mock_response = MagicMock()
        mock_response.status_code = 500
        mock_response.json.side_effect = ValueError("Not JSON")
        mock_response.text = "Plain text error"
        adapter.session.request = MagicMock(return_value=mock_response)
    
        with pytest.raises(HTTPException) as exc_info:
>           adapter.proxy_request("test-tenant", "resource/Item", method="GET")

tests/unit/test_erpnext_client.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.erpnext_client.ERPNextClientAdapter object at 0x11032ff20>
tenant_id = 'test-tenant', path = 'resource/Item', method = 'GET', params = None
json_data = None

    def proxy_request(self, tenant_id: str, path: str, method: str = "GET", params: dict = None, json_data: dict = None):
        """
        Proxies a request to the ERPNext/Frappe API using Cookie Auth with structured error handling.
    
        Args:
            tenant_id: Tenant identifier (site name)
            path: API endpoint path
            method: HTTP method
            params: Query parameters
            json_data: JSON request body
        """
        site_name = self._resolve_site_name(tenant_id)
    
        # Re-login if tenant changed
        if not self.cookie_jar or self._current_tenant != site_name:
>           login_success, login_error = self._login(site_name)
E           TypeError: cannot unpack non-iterable bool object

app/services/erpnext_client.py:152: TypeError
_________ TestGLDistributionService.test_build_gl_entries_cash_payment _________

self = <test_gl_distribution_service.TestGLDistributionService object at 0x10fa4ca50>
gl_service = <app.services.pos.gl_distribution_service.GLDistributionService object at 0x110396850>

    def test_build_gl_entries_cash_payment(self, gl_service):
        """Test GL entries for cash payment"""
        invoice_data = {
            'customer': 'CUST001',
            'grand_total': 1160.00,  # 1000 + 160 VAT
            'total_taxes_and_charges': 160.00,
            'net_total': 1000.00,
            'payments': [
                {
                    'mode_of_payment': 'Cash',
                    'amount': 1160.00,
                    'account': 'Cash Account - Main'
                }
            ],
            'items': [
                {
                    'item_code': 'TEST001',
                    'income_account': 'Sales - Test',
                    'amount': 1000.00
                }
            ],
            'taxes': [
                {
                    'account_head': 'VAT Output - Test Company',
                    'tax_amount': 160.00
                }
            ]
        }
    
>       result = gl_service.build_gl_entries(invoice_data)
E       TypeError: GLDistributionService.build_gl_entries() missing 4 required positional arguments: 'payment_accounts', 'vat_account', 'company', and 'customer'

tests/unit/test_gl_distribution_service.py:49: TypeError
________ TestGLDistributionService.test_build_gl_entries_mpesa_payment _________

self = <test_gl_distribution_service.TestGLDistributionService object at 0x10fa4f110>
gl_service = <app.services.pos.gl_distribution_service.GLDistributionService object at 0x110395e50>

    def test_build_gl_entries_mpesa_payment(self, gl_service):
        """Test GL entries for M-Pesa payment"""
        invoice_data = {
            'customer': 'CUST001',
            'grand_total': 1160.00,
            'total_taxes_and_charges': 160.00,
            'net_total': 1000.00,
            'payments': [
                {
                    'mode_of_payment': 'M-Pesa',
                    'amount': 1160.00,
                    'account': 'M-Pesa Account - Till 12345'
                }
            ],
            'items': [
                {
                    'item_code': 'TEST001',
                    'income_account': 'Sales - Test',
                    'amount': 1000.00
                }
            ],
            'taxes': [
                {
                    'account_head': 'VAT Output - Test Company',
                    'tax_amount': 160.00
                }
            ]
        }
    
>       result = gl_service.build_gl_entries(invoice_data)
E       TypeError: GLDistributionService.build_gl_entries() missing 4 required positional arguments: 'payment_accounts', 'vat_account', 'company', and 'customer'

tests/unit/test_gl_distribution_service.py:108: TypeError
______ TestGLDistributionService.test_build_gl_entries_multiple_payments _______

self = <test_gl_distribution_service.TestGLDistributionService object at 0x10fa328b0>
gl_service = <app.services.pos.gl_distribution_service.GLDistributionService object at 0x1101815b0>

    def test_build_gl_entries_multiple_payments(self, gl_service):
        """Test GL entries for multiple payment methods"""
        invoice_data = {
            'customer': 'CUST001',
            'grand_total': 2000.00,
            'total_taxes_and_charges': 320.00,
            'net_total': 1680.00,
            'payments': [
                {
                    'mode_of_payment': 'Cash',
                    'amount': 1000.00,
                    'account': 'Cash Account - Main'
                },
                {
                    'mode_of_payment': 'M-Pesa',
                    'amount': 1000.00,
                    'account': 'M-Pesa Account - Till 12345'
                }
            ],
            'items': [
                {
                    'item_code': 'TEST001',
                    'income_account': 'Sales - Test',
                    'amount': 1680.00
                }
            ],
            'taxes': [
                {
                    'account_head': 'VAT Output - Test Company',
                    'tax_amount': 320.00
                }
            ]
        }
    
>       result = gl_service.build_gl_entries(invoice_data)
E       TypeError: GLDistributionService.build_gl_entries() missing 4 required positional arguments: 'payment_accounts', 'vat_account', 'company', and 'customer'

tests/unit/test_gl_distribution_service.py:152: TypeError
________ TestGLDistributionService.test_build_gl_entries_multiple_items ________

self = <test_gl_distribution_service.TestGLDistributionService object at 0x10fa329e0>
gl_service = <app.services.pos.gl_distribution_service.GLDistributionService object at 0x1101802b0>

    def test_build_gl_entries_multiple_items(self, gl_service):
        """Test GL entries for multiple items with different accounts"""
        invoice_data = {
            'customer': 'CUST001',
            'grand_total': 2320.00,  # 2000 + 320 VAT
            'total_taxes_and_charges': 320.00,
            'net_total': 2000.00,
            'payments': [
                {
                    'mode_of_payment': 'Cash',
                    'amount': 2320.00,
                    'account': 'Cash Account - Main'
                }
            ],
            'items': [
                {
                    'item_code': 'PHONE001',
                    'income_account': 'Sales - Electronics',
                    'amount': 1200.00
                },
                {
                    'item_code': 'ACCESSORY001',
                    'income_account': 'Sales - Accessories',
                    'amount': 800.00
                }
            ],
            'taxes': [
                {
                    'account_head': 'VAT Output - Test Company',
                    'tax_amount': 320.00
                }
            ]
        }
    
>       result = gl_service.build_gl_entries(invoice_data)
E       TypeError: GLDistributionService.build_gl_entries() missing 4 required positional arguments: 'payment_accounts', 'vat_account', 'company', and 'customer'

tests/unit/test_gl_distribution_service.py:196: TypeError
___________ TestGLDistributionService.test_build_gl_entries_no_taxes ___________

self = <test_gl_distribution_service.TestGLDistributionService object at 0x10fa6d010>
gl_service = <app.services.pos.gl_distribution_service.GLDistributionService object at 0x1161e67b0>

    def test_build_gl_entries_no_taxes(self, gl_service):
        """Test GL entries for invoice with no taxes"""
        invoice_data = {
            'customer': 'CUST001',
            'grand_total': 1000.00,
            'total_taxes_and_charges': 0.00,
            'net_total': 1000.00,
            'payments': [
                {
                    'mode_of_payment': 'Cash',
                    'amount': 1000.00,
                    'account': 'Cash Account - Main'
                }
            ],
            'items': [
                {
                    'item_code': 'TEST001',
                    'income_account': 'Sales - Test',
                    'amount': 1000.00
                }
            ],
            'taxes': []
        }
    
>       result = gl_service.build_gl_entries(invoice_data)
E       TypeError: GLDistributionService.build_gl_entries() missing 4 required positional arguments: 'payment_accounts', 'vat_account', 'company', and 'customer'

tests/unit/test_gl_distribution_service.py:232: TypeError
_________ TestGLDistributionService.test_rounding_precision_gl_entries _________

self = <test_gl_distribution_service.TestGLDistributionService object at 0x10f937e50>
gl_service = <app.services.pos.gl_distribution_service.GLDistributionService object at 0x1161a8950>

    def test_rounding_precision_gl_entries(self, gl_service):
        """Test GL entries handle decimal precision correctly"""
        invoice_data = {
            'customer': 'CUST001',
            'grand_total': 1160.01,  # Slightly odd amount
            'total_taxes_and_charges': 160.01,
            'net_total': 1000.00,
            'payments': [
                {
                    'mode_of_payment': 'Cash',
                    'amount': 1160.01,
                    'account': 'Cash Account - Main'
                }
            ],
            'items': [
                {
                    'item_code': 'TEST001',
                    'income_account': 'Sales - Test',
                    'amount': 1000.00
                }
            ],
            'taxes': [
                {
                    'account_head': 'VAT Output - Test Company',
                    'tax_amount': 160.01
                }
            ]
        }
    
>       result = gl_service.build_gl_entries(invoice_data)
E       TypeError: GLDistributionService.build_gl_entries() missing 4 required positional arguments: 'payment_accounts', 'vat_account', 'company', and 'customer'

tests/unit/test_gl_distribution_service.py:301: TypeError
____________ TestImportServiceExpanded.test_import_inventory_items _____________

self = <test_import_service_expanded.TestImportServiceExpanded object at 0x10fad4550>
import_service = <app.services.import_service.ImportService object at 0x10ff66970>
mock_db = <MagicMock id='4560979344'>

    def test_import_inventory_items(self, import_service, mock_db):
        """Test importing inventory items."""
        tenant_id = uuid.uuid4()
    
        # Mock CSV data
        csv_data = "item_code,item_name,item_group,stock_uom\nITEM-001,Test Item,Products,Nos"
    
        # Mock existing item check (not found)
        mock_db.execute.return_value.scalar_one_or_none.return_value = None
    
        # Mock ERPNext adapter
        with patch('app.services.import_service.erpnext_adapter') as mock_adapter:
            mock_adapter.create_resource.return_value = {"data": {"name": "ITEM-001"}}
    
>           result = import_service.import_inventory_items(
                mock_db, tenant_id, StringIO(csv_data)
            )
E           AttributeError: 'ImportService' object has no attribute 'import_inventory_items'. Did you mean: 'import_inventory'?

tests/unit/test_import_service_expanded.py:38: AttributeError
_______________ TestImportServiceExpanded.test_import_warehouses _______________

self = <test_import_service_expanded.TestImportServiceExpanded object at 0x10fad4410>
import_service = <app.services.import_service.ImportService object at 0x1161111d0>
mock_db = <MagicMock id='4560993792'>

    def test_import_warehouses(self, import_service, mock_db):
        """Test importing warehouses."""
        tenant_id = uuid.uuid4()
    
        # Mock CSV data
        csv_data = "warehouse_name,company,warehouse_type\nMain Warehouse,Paint Shop Ltd,Store"
    
        # Mock existing warehouse check (not found)
        mock_db.execute.return_value.scalar_one_or_none.return_value = None
    
        # Mock ERPNext adapter
        with patch('app.services.import_service.erpnext_adapter') as mock_adapter:
            mock_adapter.create_resource.return_value = {"data": {"name": "Main Warehouse"}}
    
>           result = import_service.import_warehouses(
                mock_db, tenant_id, StringIO(csv_data)
            )

tests/unit/test_import_service_expanded.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/import_service.py:173: in import_warehouses
    company_name = self._resolve_company_name(tenant_id, db)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.import_service.ImportService object at 0x1161111d0>
tenant_id = UUID('62119636-2358-4c30-93ef-6a2091845810')
db = <_io.StringIO object at 0x1103c71c0>

    def _resolve_company_name(self, tenant_id: str, db: Session) -> str:
        """Resolve company name from tenant settings (priority) or tenant name (fallback)."""
>       tenant = db.execute(select(Tenant).where(Tenant.id == tenant_id)).scalar_one_or_none()
E       AttributeError: '_io.StringIO' object has no attribute 'execute'

app/services/import_service.py:121: AttributeError
______________ TestImportServiceExpanded.test_import_storefronts _______________

self = <test_import_service_expanded.TestImportServiceExpanded object at 0x10fa32d70>
import_service = <app.services.import_service.ImportService object at 0x1159568f0>
mock_db = <MagicMock id='4560992784'>

    def test_import_storefronts(self, import_service, mock_db):
        """Test importing storefronts."""
        tenant_id = uuid.uuid4()
    
        # Mock CSV data
        csv_data = "storefront_name,location,is_active\nStore 1,Nairobi,1"
    
        # Mock existing storefront check (not found)
        mock_db.execute.return_value.scalar_one_or_none.return_value = None
    
        # Mock ERPNext adapter
        with patch('app.services.import_service.erpnext_adapter') as mock_adapter:
            mock_adapter.create_resource.return_value = {"data": {"name": "Store 1"}}
    
>           result = import_service.import_storefronts(
                mock_db, tenant_id, StringIO(csv_data)
            )

tests/unit/test_import_service_expanded.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/import_service.py:202: in import_storefronts
    company_name = self._resolve_company_name(tenant_id, db)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.import_service.ImportService object at 0x1159568f0>
tenant_id = UUID('39dc0150-822d-4c58-94b8-dd0a347612e8')
db = <_io.StringIO object at 0x1103c5fc0>

    def _resolve_company_name(self, tenant_id: str, db: Session) -> str:
        """Resolve company name from tenant settings (priority) or tenant name (fallback)."""
>       tenant = db.execute(select(Tenant).where(Tenant.id == tenant_id)).scalar_one_or_none()
E       AttributeError: '_io.StringIO' object has no attribute 'execute'

app/services/import_service.py:121: AttributeError
__________ TestImportServiceExpanded.test_import_users_with_existing ___________

self = <test_import_service_expanded.TestImportServiceExpanded object at 0x10fa32ea0>
import_service = <app.services.import_service.ImportService object at 0x1103c6810>
mock_db = <MagicMock id='4564040880'>

    def test_import_users_with_existing(self, import_service, mock_db):
        """Test importing users when some already exist."""
        tenant_id = uuid.uuid4()
    
        # Mock CSV data
        csv_data = "email,first_name,last_name,role\nuser1@test.com,John,Doe,USER\nuser2@test.com,Jane,Smith,ADMIN"
    
        # Mock existing user check - first exists, second doesn't
        def mock_scalar_one_or_none():
            call_count = getattr(mock_scalar_one_or_none, 'call_count', 0)
            mock_scalar_one_or_none.call_count = call_count + 1
            if call_count == 1:
                # First user exists
                mock_user = User()
                mock_user.id = uuid.uuid4()
                return mock_user
            return None
    
        mock_db.execute.return_value.scalar_one_or_none.side_effect = mock_scalar_one_or_none
    
        # Mock tenant check
        mock_tenant = Tenant()
        mock_tenant.id = tenant_id
        mock_db.execute.return_value.scalar_one_or_none.return_value = mock_tenant
    
        # Mock password hashing
        with patch('app.services.import_service.auth_service') as mock_auth:
            mock_auth.get_password_hash.return_value = "hashed_password"
    
>           result = import_service.import_users(
                mock_db, tenant_id, StringIO(csv_data)
            )

tests/unit/test_import_service_expanded.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.import_service.ImportService object at 0x1103c6810>
data = <MagicMock id='4564040880'>
tenant_id = UUID('b2ab07a6-9b1c-48e6-91c3-152853dcfdb9')
db = <_io.StringIO object at 0x1103c6e00>

    def import_users(self, data: List[Dict[str, Any]], tenant_id: str, db: Session) -> Dict[str, Any]:
        """Creates users and memberships."""
        created_count = 0
    
        # Resolve Tenant
>       tenant = db.execute(select(Tenant).where(Tenant.id == tenant_id)).scalar_one_or_none()
E       AttributeError: '_io.StringIO' object has no attribute 'execute'

app/services/import_service.py:59: AttributeError
_________ TestOnboardingOrchestrator.test_initiate_onboarding_success __________

self = <test_onboarding_service.TestOnboardingOrchestrator object at 0x10fad4910>
onboarding_service = <app.services.onboarding_service.OnboardingOrchestrator object at 0x11009bb60>
mock_db = <Mock id='4564035840'>
mock_tenant = <Mock name='mock.filter().first()' spec='Tenant' id='4564036176'>

    def test_initiate_onboarding_success(self, onboarding_service, mock_db, mock_tenant):
        """Test successful onboarding initiation."""
        # Setup query chain mocks
        query_mock = Mock()
        filter_mock = Mock()
    
        # First query: get tenant
        query_mock.filter.return_value = filter_mock
        filter_mock.first.return_value = mock_tenant
    
        # Second query: check existing onboarding (none)
        # The query uses: .filter().filter().first() where second filter uses .in_()
        query_mock2 = Mock()
        filter_mock2 = Mock()
        # First filter() call
        query_mock2.filter.return_value = filter_mock2
        # Second filter() call with .in_() - need to handle this
        filter_mock2.filter.return_value = filter_mock2
        filter_mock2.first.return_value = None  # No existing onboarding
    
        # Setup side_effect for multiple query calls
        mock_db.query.side_effect = [query_mock, query_mock2]
    
        # Mock commit and refresh
        mock_db.commit.return_value = None
        mock_db.refresh.return_value = None
        mock_db.flush.return_value = None
    
>       result = onboarding_service.initiate_onboarding(
            str(mock_tenant.id),
            "STARTUP",
            custom_config=None,
            initiated_by_user_id=str(uuid.uuid4())
        )

tests/unit/test_onboarding_service.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
app/services/onboarding_service.py:173: in initiate_onboarding
    paused_onboarding = self.db.query(TenantOnboarding).filter(
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1169: in __call__
    return self._mock_call(*args, **kwargs)
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1173: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='mock.query' id='4564027776'>
args = (<class 'app.models.onboarding.TenantOnboarding'>,), kwargs = {}
effect = <list_iterator object at 0x11030f910>

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
                raise effect
            elif not _callable(effect):
>               result = next(effect)
E               StopIteration

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:1230: StopIteration
__________ TestOnboardingOrchestratorExpanded.test_skip_step_success ___________

self = <test_onboarding_service_expanded.TestOnboardingOrchestratorExpanded object at 0x10fa33490>
orchestrator = <app.services.onboarding_service.OnboardingOrchestrator object at 0x11619d590>
mock_db = <MagicMock id='4659616064'>

    def test_skip_step_success(self, orchestrator, mock_db):
        """Test skipping an onboarding step."""
        tenant_id = str(uuid.uuid4())
        step_code = "setup_warehouse"
    
        # Mock onboarding
        mock_onboarding = TenantOnboarding()
        mock_onboarding.id = uuid.uuid4()
        mock_onboarding.tenant_id = uuid.UUID(tenant_id)
        mock_onboarding.status = "IN_PROGRESS"
    
        # Mock step
        mock_step = OnboardingStep()
        mock_step.step_code = step_code
        mock_step.status = "PENDING"
    
        # Mock _get_active_onboarding
        with patch.object(orchestrator, '_get_active_onboarding', return_value=mock_onboarding):
            mock_db.query().filter().filter().first.return_value = mock_step
    
>           result = orchestrator.skip_step(tenant_id, step_code)

tests/unit/test_onboarding_service_expanded.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.onboarding_service.OnboardingOrchestrator object at 0x11619d590>
tenant_id = '743c992c-2a82-443f-bee6-c30fcfbd138d'
step_code = 'setup_warehouse'

    def skip_step(self, tenant_id: str, step_code: str) -> OnboardingStep:
        """Skip a step and mark as skipped."""
        onboarding = self._get_active_onboarding(tenant_id)
    
        step = self.db.query(OnboardingStep).filter(
            OnboardingStep.onboarding_id == onboarding.id,
            OnboardingStep.step_code == step_code
        ).first()
    
        if not step:
            raise ValueError(f"Step {step_code} not found")
    
        if step.status != "PENDING":
>           raise ValueError(f"Cannot skip step in {step.status} status")
E           ValueError: Cannot skip step in <MagicMock name='mock.query().filter().first().status' id='4659614384'> status

app/services/onboarding_service.py:303: ValueError
_________ TestOnboardingOrchestratorExpanded.test_skip_step_not_found __________

self = <test_onboarding_service_expanded.TestOnboardingOrchestratorExpanded object at 0x10fa335c0>
orchestrator = <app.services.onboarding_service.OnboardingOrchestrator object at 0x11619dbf0>
mock_db = <MagicMock id='4564033152'>

    def test_skip_step_not_found(self, orchestrator, mock_db):
        """Test skipping a step that doesn't exist."""
        tenant_id = str(uuid.uuid4())
        step_code = "nonexistent_step"
    
        # Mock onboarding
        mock_onboarding = TenantOnboarding()
        mock_onboarding.id = uuid.uuid4()
        mock_onboarding.tenant_id = uuid.UUID(tenant_id)
    
        # Mock _get_active_onboarding
        with patch.object(orchestrator, '_get_active_onboarding', return_value=mock_onboarding):
            mock_db.query().filter().filter().first.return_value = None
    
            with pytest.raises(ValueError, match="Step.*not found"):
>               orchestrator.skip_step(tenant_id, step_code)

tests/unit/test_onboarding_service_expanded.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.onboarding_service.OnboardingOrchestrator object at 0x11619dbf0>
tenant_id = '2a5961a6-32a6-4c45-ab92-162a5827c5d0'
step_code = 'nonexistent_step'

    def skip_step(self, tenant_id: str, step_code: str) -> OnboardingStep:
        """Skip a step and mark as skipped."""
        onboarding = self._get_active_onboarding(tenant_id)
    
        step = self.db.query(OnboardingStep).filter(
            OnboardingStep.onboarding_id == onboarding.id,
            OnboardingStep.step_code == step_code
        ).first()
    
        if not step:
            raise ValueError(f"Step {step_code} not found")
    
        if step.status != "PENDING":
>           raise ValueError(f"Cannot skip step in {step.status} status")
E           ValueError: Cannot skip step in <MagicMock name='mock.query().filter().first().status' id='4659611024'> status

app/services/onboarding_service.py:303: ValueError

During handling of the above exception, another exception occurred:

self = <test_onboarding_service_expanded.TestOnboardingOrchestratorExpanded object at 0x10fa335c0>
orchestrator = <app.services.onboarding_service.OnboardingOrchestrator object at 0x11619dbf0>
mock_db = <MagicMock id='4564033152'>

    def test_skip_step_not_found(self, orchestrator, mock_db):
        """Test skipping a step that doesn't exist."""
        tenant_id = str(uuid.uuid4())
        step_code = "nonexistent_step"
    
        # Mock onboarding
        mock_onboarding = TenantOnboarding()
        mock_onboarding.id = uuid.uuid4()
        mock_onboarding.tenant_id = uuid.UUID(tenant_id)
    
        # Mock _get_active_onboarding
        with patch.object(orchestrator, '_get_active_onboarding', return_value=mock_onboarding):
            mock_db.query().filter().filter().first.return_value = None
    
>           with pytest.raises(ValueError, match="Step.*not found"):
E           AssertionError: Regex pattern did not match.
E            Regex: 'Step.*not found'
E            Input: "Cannot skip step in <MagicMock name='mock.query().filter().first().status' id='4659611024'> status"

tests/unit/test_onboarding_service_expanded.py:99: AssertionError
_____ TestOnboardingOrchestratorExpanded.test_execute_next_step_no_pending _____

self = <test_onboarding_service_expanded.TestOnboardingOrchestratorExpanded object at 0x10faee8d0>
orchestrator = <app.services.onboarding_service.OnboardingOrchestrator object at 0x10fdb9c50>
mock_db = <MagicMock id='4564029456'>

    def test_execute_next_step_no_pending(self, orchestrator, mock_db):
        """Test executing next step when no pending steps."""
        tenant_id = str(uuid.uuid4())
    
        # Mock onboarding with all steps completed
        mock_onboarding = TenantOnboarding()
        mock_onboarding.id = uuid.uuid4()
        mock_onboarding.tenant_id = uuid.UUID(tenant_id)
        mock_onboarding.status = "IN_PROGRESS"
    
        # Mock _get_active_onboarding
        with patch.object(orchestrator, '_get_active_onboarding', return_value=mock_onboarding):
            # Mock no pending steps
            mock_db.query().filter().filter().order_by().first.return_value = None
    
            result = orchestrator.execute_next_step(tenant_id)
    
>           assert result is None  # Returns None when no pending steps
E           AssertionError: assert <MagicMock name='mock.query().filter().order_by().first()' id='4564038528'> is None

tests/unit/test_onboarding_service_expanded.py:119: AssertionError
____________ TestProvisioningService.test_step_engine_check_success ____________

self = <test_provisioning_service.TestProvisioningService object at 0x10fad4e10>
provisioning_service = <app.services.provisioning_service.ProvisioningService object at 0x10fcbd310>
mock_db = <Mock id='4560990432'>
mock_tenant = <Mock spec='Tenant' id='4659614048'>
mock_onboarding = <Mock spec='TenantOnboarding' id='4659614384'>

    def test_step_engine_check_success(self, provisioning_service, mock_db, mock_tenant, mock_onboarding):
        """Test successful engine health check."""
        with patch('app.services.provisioning_service.engine_health_service') as mock_health:
            mock_health.check_engine_health.return_value = EngineHealthResult(
                status=EngineHealthStatus.ONLINE,
                message="Engine is online",
                checked_at=datetime.now(timezone.utc),
                response_time_ms=100.0
            )
    
>           result = provisioning_service._step_engine_check(
                str(mock_tenant.id),
                mock_db,
                mock_onboarding,
                "test-correlation-id"
            )
E           TypeError: ProvisioningService._step_engine_check() missing 1 required positional argument: 'correlation_id'

tests/unit/test_provisioning_service.py:87: TypeError
____________ TestProvisioningService.test_step_engine_check_offline ____________

self = <test_provisioning_service.TestProvisioningService object at 0x10fad4f50>
provisioning_service = <app.services.provisioning_service.ProvisioningService object at 0x110395590>
mock_db = <Mock id='4659616064'>
mock_tenant = <Mock spec='Tenant' id='4659618416'>
mock_onboarding = <Mock spec='TenantOnboarding' id='4659618752'>

    def test_step_engine_check_offline(self, provisioning_service, mock_db, mock_tenant, mock_onboarding):
        """Test engine offline scenario."""
        with patch('app.services.provisioning_service.engine_health_service') as mock_health:
            mock_health.check_engine_health.return_value = EngineHealthResult(
                status=EngineHealthStatus.OFFLINE,
                message="Engine is offline",
                checked_at=datetime.now(timezone.utc),
                error="Connection failed"
            )
    
>           result = provisioning_service._step_engine_check(
                str(mock_tenant.id),
                mock_db,
                mock_onboarding,
                "test-correlation-id"
            )
E           TypeError: ProvisioningService._step_engine_check() missing 1 required positional argument: 'correlation_id'

tests/unit/test_provisioning_service.py:108: TypeError
__________ TestProvisioningService.test_step_company_creation_success __________

self = <test_provisioning_service.TestProvisioningService object at 0x10fa33820>
provisioning_service = <app.services.provisioning_service.ProvisioningService object at 0x110181220>
mock_db = <Mock id='4659619760'>
mock_tenant = <Mock spec='Tenant' id='4659621440'>
mock_onboarding = <Mock spec='TenantOnboarding' id='4659621776'>
provisioning_config = ProvisioningConfig(include_demo_data=False, pos_store_enabled=True, country_template=None)

    def test_step_company_creation_success(self, provisioning_service, mock_db, mock_tenant, mock_onboarding, provisioning_config):
        """Test successful company creation."""
        with patch('app.services.provisioning_service.erpnext_adapter') as mock_adapter:
            # Mock list companies (empty - company doesn't exist)
            mock_adapter.proxy_request.return_value = {"data": []}
    
            # Mock create company
            mock_adapter.create_resource.return_value = {
                "name": mock_tenant.name,
                "company_name": mock_tenant.name
            }
    
>           result = provisioning_service._step_company_creation(
                str(mock_tenant.id),
                provisioning_config,
                mock_db,
                mock_onboarding,
                "test-correlation-id"
            )
E           AttributeError: 'ProvisioningService' object has no attribute '_step_company_creation'

tests/unit/test_provisioning_service.py:131: AttributeError
________ TestProvisioningService.test_step_company_creation_idempotent _________

self = <test_provisioning_service.TestProvisioningService object at 0x10fa33950>
provisioning_service = <app.services.provisioning_service.ProvisioningService object at 0x110181cd0>
mock_db = <Mock id='4659623456'>
mock_tenant = <Mock spec='Tenant' id='4659625136'>
mock_onboarding = <Mock spec='TenantOnboarding' id='4659625472'>
provisioning_config = ProvisioningConfig(include_demo_data=False, pos_store_enabled=True, country_template=None)

    def test_step_company_creation_idempotent(self, provisioning_service, mock_db, mock_tenant, mock_onboarding, provisioning_config):
        """Test idempotent company creation (company already exists)."""
        with patch('app.services.provisioning_service.erpnext_adapter') as mock_adapter:
            # Mock list companies (company exists)
            mock_adapter.proxy_request.return_value = {
                "data": [{"name": mock_tenant.name}]
            }
    
>           result = provisioning_service._step_company_creation(
                str(mock_tenant.id),
                provisioning_config,
                mock_db,
                mock_onboarding,
                "test-correlation-id"
            )
E           AttributeError: 'ProvisioningService' object has no attribute '_step_company_creation'

tests/unit/test_provisioning_service.py:151: AttributeError
_________ TestProvisioningService.test_step_chart_of_accounts_success __________

self = <test_provisioning_service.TestProvisioningService object at 0x10faef770>
provisioning_service = <app.services.provisioning_service.ProvisioningService object at 0x115bd85f0>
mock_db = <Mock id='4569187392'>
mock_tenant = <Mock spec='Tenant' id='4569189072'>
mock_onboarding = <Mock spec='TenantOnboarding' id='4569189408'>
provisioning_config = ProvisioningConfig(include_demo_data=False, pos_store_enabled=True, country_template=None)

    def test_step_chart_of_accounts_success(self, provisioning_service, mock_db, mock_tenant, mock_onboarding, provisioning_config):
        """Test successful chart of accounts import."""
        mock_onboarding.provisioning_metadata = {"company_name": mock_tenant.name}
    
        with patch('app.services.provisioning_service.erpnext_adapter') as mock_adapter:
            # Mock idempotency check (no accounts exist)
            mock_adapter.proxy_request.side_effect = [
                {"data": []},  # Existing accounts check
                {"data": [{"name": "Account 1"}, {"name": "Account 2"}]}  # After import
            ]
    
            # Mock import_chart_of_accounts
            mock_adapter.import_chart_of_accounts.return_value = {
                "status": "success",
                "message": "Chart of accounts imported successfully",
                "accounts_count": 2
            }
    
            result = provisioning_service._step_chart_of_accounts(
                str(mock_tenant.id),
                provisioning_config,
                mock_db,
                mock_onboarding,
                "test-correlation-id"
            )
    
>           assert result.status == "completed"
E           AssertionError: assert 'failed' == 'completed'
E             
E             - completed
E             + failed

tests/unit/test_provisioning_service.py:190: AssertionError
________ TestProvisioningService.test_step_chart_of_accounts_idempotent ________

self = <test_provisioning_service.TestProvisioningService object at 0x10fb048d0>
provisioning_service = <app.services.provisioning_service.ProvisioningService object at 0x11619d150>
mock_db = <Mock id='4569193776'>
mock_tenant = <Mock spec='Tenant' id='4569195792'>
mock_onboarding = <Mock spec='TenantOnboarding' id='4569196128'>
provisioning_config = ProvisioningConfig(include_demo_data=False, pos_store_enabled=True, country_template=None)

    def test_step_chart_of_accounts_idempotent(self, provisioning_service, mock_db, mock_tenant, mock_onboarding, provisioning_config):
        """Test idempotent chart of accounts import (accounts already exist)."""
        mock_onboarding.provisioning_metadata = {"company_name": mock_tenant.name}
    
        with patch('app.services.provisioning_service.erpnext_adapter') as mock_adapter:
            # Mock idempotency check (accounts exist)
            mock_adapter.proxy_request.return_value = {
                "data": [{"name": "Account 1"}, {"name": "Account 2"}, {"name": "Account 3"}]
            }
    
            # Mock import_chart_of_accounts (returns exists)
            mock_adapter.import_chart_of_accounts.return_value = {
                "status": "exists",
                "message": "Chart of accounts already exists",
                "accounts_count": 3
            }
    
            result = provisioning_service._step_chart_of_accounts(
                str(mock_tenant.id),
                provisioning_config,
                mock_db,
                mock_onboarding,
                "test-correlation-id"
            )
    
>           assert result.status == "exists"
E           AssertionError: assert 'failed' == 'exists'
E             
E             - exists
E             + failed

tests/unit/test_provisioning_service.py:219: AssertionError
_____________ TestProvisioningService.test_step_warehouses_success _____________

self = <test_provisioning_service.TestProvisioningService object at 0x10fb049e0>
provisioning_service = <app.services.provisioning_service.ProvisioningService object at 0x11619fac0>
mock_db = <Mock id='4569200496'>
mock_tenant = <Mock spec='Tenant' id='4569202176'>
mock_onboarding = <Mock spec='TenantOnboarding' id='4568825936'>
provisioning_config = ProvisioningConfig(include_demo_data=False, pos_store_enabled=True, country_template=None)

    def test_step_warehouses_success(self, provisioning_service, mock_db, mock_tenant, mock_onboarding, provisioning_config):
        """Test successful warehouse creation."""
        mock_onboarding.provisioning_metadata = {"company_name": mock_tenant.name}
    
        with patch('app.services.provisioning_service.erpnext_adapter') as mock_adapter:
            # Mock list warehouses (empty)
            mock_adapter.proxy_request.return_value = {"data": []}
    
            # Mock create warehouse
            mock_adapter.create_resource.return_value = {"name": "Main Store"}
    
>           result = provisioning_service._step_warehouses(
                str(mock_tenant.id),
                provisioning_config,
                mock_db,
                mock_onboarding,
                "test-correlation-id"
            )

tests/unit/test_provisioning_service.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.provisioning_service.ProvisioningService object at 0x11619fac0>
tenant_id = '8f34a340-2975-40bf-a022-8976e4a45406'
config = ProvisioningConfig(include_demo_data=False, pos_store_enabled=True, country_template=None)
db = <Mock id='4569200496'>
onboarding = <Mock spec='TenantOnboarding' id='4568825936'>
correlation_id = 'test-correlation-id'

    def _step_warehouses(
        self,
        tenant_id: str,
        config: ProvisioningConfig,
        db: Session,
        onboarding: TenantOnboarding,
        correlation_id: str
    ) -> StepResult:
        """Step 4: Create Warehouses"""
        start_time = time.time()
    
        try:
            company_name = onboarding.provisioning_metadata.get("company_name") if onboarding.provisioning_metadata else None
            if not company_name:
                tenant = db.query(Tenant).filter(Tenant.id == tenant_id).first()
                company_name = tenant.name
    
            # Resolve company abbreviation to place warehouses under the root
            root_warehouse = None
            enable_perpetual_inventory = False
            try:
                company_doc = erpnext_adapter.proxy_request(
                    tenant_id,
                    f"resource/Company/{company_name}",
                    method="GET"
                )
                company_data = company_doc.get("data", {}) if isinstance(company_doc, dict) else {}
                company_abbr = company_data.get("abbr") or company_data.get("abbreviation")
                enable_perpetual_inventory = bool(company_data.get("enable_perpetual_inventory"))
                if company_abbr:
                    from urllib.parse import quote
                    candidate_root = f"All Warehouses - {company_abbr}"
                    erpnext_adapter.proxy_request(
                        tenant_id,
                        f"resource/Warehouse/{quote(candidate_root)}",
                        method="GET"
                    )
                    root_warehouse = candidate_root
            except Exception:
                root_warehouse = None
    
            # Validate Chart of Accounts exists for company
            accounts_response = erpnext_adapter.proxy_request(
                tenant_id,
                "resource/Account",
                method="GET",
                params={
                    "filters": f'[["company", "=", "{company_name}"]]',
                    "limit_page_length": 1,
                    "fields": '["name","account_type","account_name"]'
                }
            )
            accounts = accounts_response.get("data", []) if isinstance(accounts_response, dict) else []
            if not accounts:
>               raise CriticalProvisioningError(
                    f"Chart of Accounts not found for company '{company_name}'. Please import chart of accounts first.",
                    "step_4_warehouses"
                )
E               app.exceptions.provisioning.CriticalProvisioningError: Chart of Accounts not found for company 'Test Tenant'. Please import chart of accounts first.

app/services/provisioning_service.py:1337: CriticalProvisioningError
______________ TestProvisioningService.test_step_settings_success ______________

self = <test_provisioning_service.TestProvisioningService object at 0x10fadcd50>
provisioning_service = <app.services.provisioning_service.ProvisioningService object at 0x10ffb9850>
mock_db = <Mock id='4569196800'>
mock_tenant = <Mock spec='Tenant' id='4569197808'>
mock_onboarding = <Mock spec='TenantOnboarding' id='4569197472'>
provisioning_config = ProvisioningConfig(include_demo_data=False, pos_store_enabled=True, country_template=None)

    def test_step_settings_success(self, provisioning_service, mock_db, mock_tenant, mock_onboarding, provisioning_config):
        """Test successful settings update."""
        mock_onboarding.provisioning_metadata = {
            "company_name": mock_tenant.name,
            "warehouse_names": ["Main Store"]
        }
    
        with patch('app.services.provisioning_service.erpnext_adapter') as mock_adapter:
            # Mock get current settings
            mock_adapter.proxy_request.side_effect = [
                {"data": {}},  # Selling Settings
                {"data": {}}   # Stock Settings
            ]
    
            # Mock update settings
            mock_adapter.update_selling_settings.return_value = {"status": "success"}
            mock_adapter.update_stock_settings.return_value = {"status": "success"}
    
            result = provisioning_service._step_settings(
                str(mock_tenant.id),
                provisioning_config,
                mock_db,
                mock_onboarding,
                "test-correlation-id"
            )
    
>           assert result.status == "completed"
E           AssertionError: assert 'failed' == 'completed'
E             
E             - completed
E             + failed

tests/unit/test_provisioning_service.py:295: AssertionError
------------------------------ Captured log call -------------------------------
WARNING  app.services.provisioning_service:provisioning_service.py:1733 [test-correlation-id] No non-group warehouse found in initial search. Re-fetching with company filter...
ERROR    app.services.provisioning_service:provisioning_service.py:1944 [test-correlation-id] Settings update failed: unknown_error -
_________ TestProvisioningService.test_provisioning_full_flow_success __________

self = <test_provisioning_service.TestProvisioningService object at 0x10faba190>
provisioning_service = <app.services.provisioning_service.ProvisioningService object at 0x1159d8d70>
mock_db = <Mock id='4569190080'>
mock_tenant = <Mock spec='Tenant' id='4569186384'>
mock_onboarding = <Mock spec='TenantOnboarding' id='4569191088'>
provisioning_config = ProvisioningConfig(include_demo_data=False, pos_store_enabled=True, country_template=None)

    def test_provisioning_full_flow_success(self, provisioning_service, mock_db, mock_tenant, mock_onboarding, provisioning_config):
        """Test full provisioning flow success."""
        # Mock all dependencies
        with patch('app.services.provisioning_service.engine_health_service') as mock_health, \
             patch('app.services.provisioning_service.erpnext_adapter') as mock_adapter:
    
            # Mock engine health check
            mock_health.check_engine_health.return_value = EngineHealthResult(
                status=EngineHealthStatus.ONLINE,
                message="Engine is online",
                checked_at=datetime.now(timezone.utc)
            )
    
            # Mock company check and creation
            mock_adapter.proxy_request.side_effect = [
                {"data": []},  # Companies list (empty)
                {"data": []},  # Accounts list (empty)
                {"data": []},  # Warehouses list (empty)
                {"data": []},  # Customers list (empty)
                {"data": []},  # POS sessions list (empty)
                {"data": {}},  # Selling Settings
                {"data": {}}   # Stock Settings
            ]
    
            mock_adapter.create_resource.side_effect = [
                {"name": mock_tenant.name},  # Company
                {"name": "Main Store"},      # Warehouse
                {"name": "POS Store"},       # Warehouse
                {"name": "Walk-In Customer"}, # Customer
                {"name": "Default POS Profile"}, # POS Profile
                {"name": "POS-OPEN-001"}     # POS Session
            ]
    
            mock_adapter.import_chart_of_accounts.return_value = {
                "status": "success",
                "message": "Chart imported",
                "accounts_count": 10
            }
    
            mock_adapter.update_selling_settings.return_value = {"status": "success"}
            mock_adapter.update_stock_settings.return_value = {"status": "success"}
    
            # Mock database queries
            mock_db.query.return_value.filter.return_value.first.side_effect = [
                mock_tenant,  # Get tenant
                None,         # No existing onboarding
            ]
    
            # Execute provisioning
            result = provisioning_service.provision_workspace_to_pos(
                str(mock_tenant.id),
                provisioning_config,
                mock_db,
                str(uuid.uuid4())
            )
    
>           assert result.status.value == "COMPLETED"
E           AssertionError: assert 'FAILED' == 'COMPLETED'
E             
E             - COMPLETED
E             + FAILED

tests/unit/test_provisioning_service.py:397: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    app.services.provisioning_service:provisioning_service.py:441 [f80c6f89-7c5f-4e38-88d7-a4cd96615235] Critical step step_0_engine_check failed, stopping provisioning
__________ TestProvisioningService.test_provisioning_critical_failure __________

self = <test_provisioning_service.TestProvisioningService object at 0x10fabac10>
provisioning_service = <app.services.provisioning_service.ProvisioningService object at 0x1161133f0>
mock_db = <Mock id='4569191760'>
mock_tenant = <Mock spec='Tenant' id='4569193440'>
mock_onboarding = <Mock spec='TenantOnboarding' id='4569196464'>
provisioning_config = ProvisioningConfig(include_demo_data=False, pos_store_enabled=True, country_template=None)

    def test_provisioning_critical_failure(self, provisioning_service, mock_db, mock_tenant, mock_onboarding, provisioning_config):
        """Test provisioning failure on critical step."""
        with patch('app.services.provisioning_service.engine_health_service') as mock_health, \
             patch('app.services.provisioning_service.erpnext_adapter') as mock_adapter:
    
            # Mock engine health check (online)
            mock_health.check_engine_health.return_value = EngineHealthResult(
                status=EngineHealthStatus.ONLINE,
                message="Engine is online",
                checked_at=datetime.now(timezone.utc)
            )
    
            # Mock company creation failure
            mock_adapter.proxy_request.return_value = {"data": []}
            mock_adapter.create_resource.side_effect = HTTPException(
                status_code=500,
                detail="Company creation failed"
            )
    
            # Mock database queries
            mock_db.query.return_value.filter.return_value.first.side_effect = [
                mock_tenant,
                None,
            ]
    
            # Execute provisioning
            result = provisioning_service.provision_workspace_to_pos(
                str(mock_tenant.id),
                provisioning_config,
                mock_db,
                str(uuid.uuid4())
            )
    
            assert result.status.value == "FAILED"
>           assert result.current_step == "step_2_company"
E           AssertionError: assert 'step_0_engine_check' == 'step_2_company'
E             
E             - step_2_company
E             + step_0_engine_check

tests/unit/test_provisioning_service.py:435: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    app.services.provisioning_service:provisioning_service.py:441 [beb6867a-2054-4b5b-bd7d-cc5def814d8b] Critical step step_0_engine_check failed, stopping provisioning
_______ TestRBACServiceAdditional.test_grant_permission_override_success _______

self = <test_rbac_service_expanded2.TestRBACServiceAdditional object at 0x10fad6d50>
mock_db = <MagicMock id='4568832992'>
mock_user_id = UUID('6d430ef9-8fd1-4377-b88d-46426382c1a6')
mock_tenant_id = UUID('e2e77931-7e6e-4281-875e-3971fff44a2b')

    def test_grant_permission_override_success(self, mock_db, mock_user_id, mock_tenant_id):
        """Test granting permission override."""
        permission_code = "crm:leads:delete"
        expires_at = datetime.now() + timedelta(days=30)
    
        # Mock existing override check
        mock_db.query().filter().filter().filter().first.return_value = None
    
        # Mock permission lookup
        mock_permission = Permission()
        mock_permission.id = uuid.uuid4()
        mock_permission.code = permission_code
        mock_db.query().filter().first.return_value = mock_permission
    
        # Mock user role lookup
        mock_user_role = UserRole()
        mock_user_role.role_id = uuid.uuid4()
        mock_db.query().filter().filter().filter().first.return_value = mock_user_role
    
        result = rbac_service.grant_permission_override(
            mock_db, mock_user_id, mock_tenant_id, permission_code, expires_at
        )
    
        assert result is not None
>       mock_db.add.assert_called_once()

tests/unit/test_rbac_service_expanded2.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='mock.add' id='4568836352'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'add' to have been called once. Called 2 times.
E           Calls: [call(<PermissionOverride GRANT N/A>),
E            call(<RoleAuditLog PERMISSION_GRANTED at None>)].

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/unittest/mock.py:958: AssertionError
______ TestRBACServiceAdditional.test_grant_permission_override_existing _______

self = <test_rbac_service_expanded2.TestRBACServiceAdditional object at 0x10fad6e90>
mock_db = <MagicMock id='4560992112'>
mock_user_id = UUID('0058a76f-c3c5-440f-974f-21d6d5ad3e43')
mock_tenant_id = UUID('89e0541e-ab1c-4f46-ba97-3c96ddeb0bd9')

    def test_grant_permission_override_existing(self, mock_db, mock_user_id, mock_tenant_id):
        """Test granting permission override when one already exists."""
        permission_code = "crm:leads:delete"
        expires_at = datetime.now() + timedelta(days=30)
    
        # Mock existing override
        mock_override = PermissionOverride()
        mock_override.id = uuid.uuid4()
>       mock_override.is_expired = PropertyMock(return_value=False)
E       AttributeError: property 'is_expired' of 'PermissionOverride' object has no setter

tests/unit/test_rbac_service_expanded2.py:63: AttributeError
______ TestRBACServiceAdditional.test_revoke_permission_override_success _______

self = <test_rbac_service_expanded2.TestRBACServiceAdditional object at 0x10fb588a0>
mock_db = <MagicMock id='4560987744'>
mock_user_id = UUID('e8180220-2fb9-4b9d-acfc-d6db5a570988')
mock_tenant_id = UUID('13616b35-ac5d-4663-a23a-88a14138f264')

    def test_revoke_permission_override_success(self, mock_db, mock_user_id, mock_tenant_id):
        """Test revoking permission override."""
        permission_code = "crm:leads:delete"
    
        # Mock existing override
        mock_override = PermissionOverride()
        mock_override.id = uuid.uuid4()
        mock_db.query().filter().filter().filter().first.return_value = mock_override
    
>       result = rbac_service.revoke_permission_override(
            mock_db, mock_user_id, mock_tenant_id, permission_code
        )
E       TypeError: RBACService.revoke_permission_override() missing 1 required positional argument: 'revoked_by'

tests/unit/test_rbac_service_expanded2.py:82: TypeError
_____ TestRBACServiceAdditional.test_revoke_permission_override_not_found ______

self = <test_rbac_service_expanded2.TestRBACServiceAdditional object at 0x10fb589d0>
mock_db = <MagicMock id='4560979680'>
mock_user_id = UUID('386132d0-19d0-4371-8eaa-8209be5abf10')
mock_tenant_id = UUID('739efac5-1b70-4a12-a258-d4d67b6305df')

    def test_revoke_permission_override_not_found(self, mock_db, mock_user_id, mock_tenant_id):
        """Test revoking permission override when not found."""
        permission_code = "crm:leads:delete"
    
        # Mock no existing override
        mock_db.query().filter().filter().filter().first.return_value = None
    
>       result = rbac_service.revoke_permission_override(
            mock_db, mock_user_id, mock_tenant_id, permission_code
        )
E       TypeError: RBACService.revoke_permission_override() missing 1 required positional argument: 'revoked_by'

tests/unit/test_rbac_service_expanded2.py:97: TypeError
__________ TestRBACServiceAdditional.test_get_user_roles_system_wide ___________

self = <test_rbac_service_expanded2.TestRBACServiceAdditional object at 0x10fb05260>
mock_db = <MagicMock id='4564025760'>
mock_user_id = UUID('45819b6c-ca35-438e-a5d0-3546c3179965')

    def test_get_user_roles_system_wide(self, mock_db, mock_user_id):
        """Test getting user roles system-wide (no tenant)."""
        # Mock user roles
        mock_role1 = Role()
        mock_role1.code = "ADMIN"
        mock_role1.id = uuid.uuid4()
    
        mock_role2 = Role()
        mock_role2.code = "MANAGER"
        mock_role2.id = uuid.uuid4()
    
        mock_user_role1 = UserRole()
        mock_user_role1.role = mock_role1
        mock_user_role1.is_active = True
>       mock_user_role1.is_expired = PropertyMock(return_value=False)
E       AttributeError: property 'is_expired' of 'UserRole' object has no setter

tests/unit/test_rbac_service_expanded2.py:130: AttributeError
___ TestRBACServiceAdditional.test_get_effective_permissions_with_wildcards ____

self = <test_rbac_service_expanded2.TestRBACServiceAdditional object at 0x10fb05370>
mock_db = <MagicMock id='4564036512'>
mock_user_id = UUID('d04fc3b2-1333-471d-b0ae-3b8fe28b8cff')
mock_tenant_id = UUID('3e6392f0-c89b-4493-a2b0-212f07992864')

    def test_get_effective_permissions_with_wildcards(self, mock_db, mock_user_id, mock_tenant_id):
        """Test getting effective permissions with wildcard matching."""
        # Mock role permissions
        mock_permission1 = Permission()
        mock_permission1.code = "crm:*:view"
        mock_permission1.id = uuid.uuid4()
    
        mock_permission2 = Permission()
        mock_permission2.code = "inventory:items:create"
        mock_permission2.id = uuid.uuid4()
    
        mock_role_perm1 = RolePermission()
        mock_role_perm1.permission = mock_permission1
    
        mock_role_perm2 = RolePermission()
        mock_role_perm2.permission = mock_permission2
    
        # Mock user roles
        mock_role = Role()
        mock_role.id = uuid.uuid4()
        mock_user_role = UserRole()
        mock_user_role.role = mock_role
        mock_user_role.is_active = True
>       mock_user_role.is_expired = PropertyMock(return_value=False)
E       AttributeError: property 'is_expired' of 'UserRole' object has no setter

tests/unit/test_rbac_service_expanded2.py:170: AttributeError
_________ TestRBACServiceAdditional.test_has_permission_with_override __________

self = <test_rbac_service_expanded2.TestRBACServiceAdditional object at 0x10faddf50>
mock_db = <MagicMock id='4564039536'>
mock_user_id = UUID('f4e86057-a8ec-4a1a-a2b1-8510ed512605')
mock_tenant_id = UUID('12a11a0b-a7a4-4474-967b-812c1c23a05e')

    def test_has_permission_with_override(self, mock_db, mock_user_id, mock_tenant_id):
        """Test permission check with active override."""
        permission_code = "crm:leads:delete"
    
        # Mock override
        mock_override = PermissionOverride()
        mock_override.granted = True
>       mock_override.is_expired = PropertyMock(return_value=False)
E       AttributeError: property 'is_expired' of 'PermissionOverride' object has no setter

tests/unit/test_rbac_service_expanded2.py:187: AttributeError
______ TestRBACServiceAdditional.test_has_permission_with_override_denied ______

self = <test_rbac_service_expanded2.TestRBACServiceAdditional object at 0x10fade050>
mock_db = <MagicMock id='4564027104'>
mock_user_id = UUID('170aee0c-2b3f-4dd1-99bf-f73cad43a8a2')
mock_tenant_id = UUID('911ed851-45ab-4cb0-9868-3ab587f5d7df')

    def test_has_permission_with_override_denied(self, mock_db, mock_user_id, mock_tenant_id):
        """Test permission check with override that denies permission."""
        permission_code = "crm:leads:delete"
    
        # Mock override that denies
        mock_override = PermissionOverride()
        mock_override.granted = False
>       mock_override.is_expired = PropertyMock(return_value=False)
E       AttributeError: property 'is_expired' of 'PermissionOverride' object has no setter

tests/unit/test_rbac_service_expanded2.py:201: AttributeError
____________ TestRBACServiceAdditional.test_assign_role_with_expiry ____________

self = <test_rbac_service_expanded2.TestRBACServiceAdditional object at 0x10fa4a5d0>
mock_db = <MagicMock id='4564039872'>
mock_user_id = UUID('3abb1dc5-fd0f-4747-9661-fa1316aeea9d')
mock_tenant_id = UUID('252dc906-9349-4b5f-84ec-14fab7df76df')

    def test_assign_role_with_expiry(self, mock_db, mock_user_id, mock_tenant_id):
        """Test assigning role with expiry date."""
        role_code = "MANAGER"
        expires_at = datetime.now() + timedelta(days=30)
    
        # Mock role lookup
        mock_role = Role()
        mock_role.id = uuid.uuid4()
        mock_role.code = role_code
        mock_db.query().filter().first.return_value = mock_role
    
        # Mock no existing assignment
        mock_db.query().filter().filter().filter().first.return_value = None
    
>       result = rbac_service.assign_role(mock_db, mock_user_id, mock_tenant_id, role_code, expires_at)

tests/unit/test_rbac_service_expanded2.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.rbac_service.RBACService object at 0x10c292900>
db = <MagicMock id='4564039872'>
user_id = UUID('3abb1dc5-fd0f-4747-9661-fa1316aeea9d')
tenant_id = UUID('252dc906-9349-4b5f-84ec-14fab7df76df'), role_id = 'MANAGER'
assigned_by = datetime.datetime(2026, 2, 25, 20, 11, 32, 598573)
expires_at = None, ip_address = None

    def assign_role(
        self,
        db: Session,
        user_id: uuid.UUID,
        tenant_id: Optional[uuid.UUID],
        role_id: uuid.UUID,
        assigned_by: uuid.UUID,
        expires_at: Optional[datetime] = None,
        ip_address: Optional[str] = None
    ) -> UserRole:
        """
        Assign a role to a user.
    
        Args:
            db: Database session
            user_id: User to assign role to
            tenant_id: Tenant context (None for system roles)
            role_id: Role to assign
            assigned_by: User performing the assignment
            expires_at: Optional expiration date
            ip_address: IP address of requester
    
        Returns:
            UserRole object
    
        Raises:
            ValueError: If role already assigned
        """
        # Check if already assigned
        existing = db.query(UserRole).filter(
            UserRole.user_id == user_id,
            UserRole.tenant_id == tenant_id,
            UserRole.role_id == role_id,
            UserRole.is_active == True
        ).first()
    
>       if existing and not existing.is_expired:
E       AttributeError: 'Role' object has no attribute 'is_expired'

app/services/rbac_service.py:247: AttributeError
________________ TestVATService.test_calculate_vat_vatable_item ________________

self = <test_vat_service.TestVATService object at 0x10fbb91d0>
vat_service = <app.services.pos.vat_service.VATService object at 0x10fcbfb10>

    def test_calculate_vat_vatable_item(self, vat_service):
        """Test VAT calculation for vatable items"""
        amount = Decimal('1000.00')
        vat_rate = Decimal('16.0')
        is_vatable = True
    
>       result = vat_service.calculate_vat(amount, vat_rate, is_vatable)
E       AttributeError: 'VATService' object has no attribute 'calculate_vat'

tests/unit/test_vat_service.py:25: AttributeError
______________ TestVATService.test_calculate_vat_non_vatable_item ______________

self = <test_vat_service.TestVATService object at 0x10fbb9310>
vat_service = <app.services.pos.vat_service.VATService object at 0x110396d50>

    def test_calculate_vat_non_vatable_item(self, vat_service):
        """Test VAT calculation for non-vatable items"""
        amount = Decimal('1000.00')
        vat_rate = Decimal('16.0')
        is_vatable = False
    
>       result = vat_service.calculate_vat(amount, vat_rate, is_vatable)
E       AttributeError: 'VATService' object has no attribute 'calculate_vat'

tests/unit/test_vat_service.py:42: AttributeError
______________ TestVATService.test_calculate_vat_for_items_mixed _______________

self = <test_vat_service.TestVATService object at 0x10fb59e00>
vat_service = <app.services.pos.vat_service.VATService object at 0x10fcbd310>

    def test_calculate_vat_for_items_mixed(self, vat_service):
        """Test VAT calculation for mixed vatable/non-vatable items"""
        items = [
            {'amount': Decimal('1000.00'), 'vat_rate': Decimal('16.0'), 'is_vatable': True},
            {'amount': Decimal('500.00'), 'vat_rate': Decimal('16.0'), 'is_vatable': False},
            {'amount': Decimal('2000.00'), 'vat_rate': Decimal('8.0'), 'is_vatable': True}
        ]
    
>       result = vat_service.calculate_vat_for_items(items)

tests/unit/test_vat_service.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.pos.vat_service.VATService object at 0x10fcbd310>
items = [{'amount': Decimal('1000.00'), 'is_vatable': True, 'vat_rate': Decimal('16.0')}, {'amount': Decimal('500.00'), 'is_va...': False, 'vat_rate': Decimal('16.0')}, {'amount': Decimal('2000.00'), 'is_vatable': True, 'vat_rate': Decimal('8.0')}]
is_vatable = True

    def calculate_vat_for_items(self, items: List[Dict[str, Any]], is_vatable: bool = True) -> Dict[str, Any]:
        """
        Calculate VAT for a list of items
    
        Args:
            items: List of items with amount, is_vatable flag, etc.
            is_vatable: Whether the entire invoice is subject to VAT
    
        Returns:
            Dict with total_amount, total_vat, items breakdown
        """
        if not is_vatable:
            # Non-VATable invoice - return zero VAT
            total_amount = sum(item.get('amount', 0) for item in items)
            items_breakdown = [
                {
                    **item,
                    'vat_amount': 0.0,
                    'net_amount': round(item.get('amount', 0), 2),
                    'vat_rate': 0.0
                }
                for item in items
            ]
            return {
                'total_amount': round(total_amount, 2),
                'total_base': round(total_amount, 2),
                'total_vat': 0.0,
                'items': items_breakdown,
                'vat_breakdown': [
                    {
                        "item_code": i.get("item_code"),
                        "net_amount": i.get("net_amount"),
                        "vat_amount": i.get("vat_amount"),
                        "vat_rate": i.get("vat_rate")
                    }
                    for i in items_breakdown
                ]
            }
    
        total_amount = 0.0
        total_vat = 0.0
        processed_items = []
    
        for item in items:
            amount = item.get('amount', 0)
            item_vat_rate = (item.get('vat_rate') or self.default_vat_rate) / 100  # Convert percentage to decimal
    
            # Calculate VAT for this item
            vat_amount = amount * item_vat_rate
            net_amount = amount  # Net amount is the full amount before VAT
>           total_amount += net_amount + vat_amount
E           TypeError: unsupported operand type(s) for +=: 'float' and 'decimal.Decimal'

app/services/pos/vat_service.py:74: TypeError
______________ TestVATService.test_calculate_vat_for_items_empty _______________

self = <test_vat_service.TestVATService object at 0x10fb59f30>
vat_service = <app.services.pos.vat_service.VATService object at 0x1103956d0>

    def test_calculate_vat_for_items_empty(self, vat_service):
        """Test VAT calculation for empty items list"""
        result = vat_service.calculate_vat_for_items([])
    
>       assert result['total_base_amount'] == Decimal('0.00')
E       KeyError: 'total_base_amount'

tests/unit/test_vat_service.py:78: KeyError
___________ TestVATService.test_calculate_vat_for_items_none_values ____________

self = <test_vat_service.TestVATService object at 0x10fbe0170>
vat_service = <app.services.pos.vat_service.VATService object at 0x110396fd0>

    def test_calculate_vat_for_items_none_values(self, vat_service):
        """Test VAT calculation handling None values"""
        items = [
            {'amount': Decimal('1000.00'), 'vat_rate': None, 'is_vatable': True}
        ]
    
        # Should use default VAT rate for None values
>       result = vat_service.calculate_vat_for_items(items)

tests/unit/test_vat_service.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.pos.vat_service.VATService object at 0x110396fd0>
items = [{'amount': Decimal('1000.00'), 'is_vatable': True, 'vat_rate': None}]
is_vatable = True

    def calculate_vat_for_items(self, items: List[Dict[str, Any]], is_vatable: bool = True) -> Dict[str, Any]:
        """
        Calculate VAT for a list of items
    
        Args:
            items: List of items with amount, is_vatable flag, etc.
            is_vatable: Whether the entire invoice is subject to VAT
    
        Returns:
            Dict with total_amount, total_vat, items breakdown
        """
        if not is_vatable:
            # Non-VATable invoice - return zero VAT
            total_amount = sum(item.get('amount', 0) for item in items)
            items_breakdown = [
                {
                    **item,
                    'vat_amount': 0.0,
                    'net_amount': round(item.get('amount', 0), 2),
                    'vat_rate': 0.0
                }
                for item in items
            ]
            return {
                'total_amount': round(total_amount, 2),
                'total_base': round(total_amount, 2),
                'total_vat': 0.0,
                'items': items_breakdown,
                'vat_breakdown': [
                    {
                        "item_code": i.get("item_code"),
                        "net_amount": i.get("net_amount"),
                        "vat_amount": i.get("vat_amount"),
                        "vat_rate": i.get("vat_rate")
                    }
                    for i in items_breakdown
                ]
            }
    
        total_amount = 0.0
        total_vat = 0.0
        processed_items = []
    
        for item in items:
            amount = item.get('amount', 0)
            item_vat_rate = (item.get('vat_rate') or self.default_vat_rate) / 100  # Convert percentage to decimal
    
            # Calculate VAT for this item
>           vat_amount = amount * item_vat_rate
E           TypeError: unsupported operand type(s) for *: 'decimal.Decimal' and 'float'

app/services/pos/vat_service.py:72: TypeError
____________________ TestVATService.test_rounding_precision ____________________

self = <test_vat_service.TestVATService object at 0x10fadea50>
vat_service = <app.services.pos.vat_service.VATService object at 0x110396c10>

    def test_rounding_precision(self, vat_service):
        """Test VAT calculation rounding precision"""
        amount = Decimal('123.456')
        vat_rate = Decimal('16.00')
    
>       result = vat_service.calculate_vat(amount, vat_rate, True)
E       AttributeError: 'VATService' object has no attribute 'calculate_vat'

tests/unit/test_vat_service.py:138: AttributeError
___________________ TestVATService.test_zero_amount_handling ___________________

self = <test_vat_service.TestVATService object at 0x10fa4aa80>
vat_service = <app.services.pos.vat_service.VATService object at 0x110397390>

    def test_zero_amount_handling(self, vat_service):
        """Test VAT calculation with zero amounts"""
>       result = vat_service.calculate_vat(Decimal('0.00'), Decimal('16.0'), True)
E       AttributeError: 'VATService' object has no attribute 'calculate_vat'

tests/unit/test_vat_service.py:149: AttributeError
_________________ TestVATService.test_negative_amount_handling _________________

self = <test_vat_service.TestVATService object at 0x10fa4ab70>
vat_service = <app.services.pos.vat_service.VATService object at 0x1104f4550>

    def test_negative_amount_handling(self, vat_service):
        """Test VAT calculation with negative amounts (edge case)"""
>       result = vat_service.calculate_vat(Decimal('-100.00'), Decimal('16.0'), True)
E       AttributeError: 'VATService' object has no attribute 'calculate_vat'

tests/unit/test_vat_service.py:157: AttributeError
=============================== warnings summary ===============================
../../../../../Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pydantic/_internal/_config.py:295: 29 warnings
  /Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pydantic/_internal/_config.py:295: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.10/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

../../../../../Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/reportlab/lib/rl_safe_eval.py:12
  /Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/reportlab/lib/rl_safe_eval.py:12: DeprecationWarning: ast.NameConstant is deprecated and will be removed in Python 3.14; use ast.Constant instead
    haveNameConstant = hasattr(ast,'NameConstant')

../../../../../Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pydantic/fields.py:1011
../../../../../Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pydantic/fields.py:1011
  /Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pydantic/fields.py:1011: PydanticDeprecatedSince20: `min_items` is deprecated and will be removed, use `min_length` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.10/migration/
    warn('`min_items` is deprecated and will be removed, use `min_length` instead', DeprecationWarning)

app/models/paint.py:10
  /Volumes/Stuff/Start Ups/MoranERP/Backend/app/models/paint.py:10: MovedIn20Warning: The ``declarative_base()`` function is now available as sqlalchemy.orm.declarative_base(). (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    Base = declarative_base()

app/main.py:101
  /Volumes/Stuff/Start Ups/MoranERP/Backend/app/main.py:101: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @app.on_event("startup")

../../../../../Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/fastapi/applications.py:4495
  /Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/fastapi/applications.py:4495: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    return self.router.on_event(event_type)

tests/unit/test_auth_service.py::TestAuthService::test_verify_password_success
  /Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/passlib/handlers/argon2.py:716: DeprecationWarning: Accessing argon2.__version__ is deprecated and will be removed in a future release. Use importlib.metadata directly to query for argon2-cffi's packaging metadata.
    _argon2_cffi.__version__, max_version)

tests/unit/test_auth_service.py::TestAuthService::test_create_access_token_default_expiry
tests/unit/test_auth_service.py::TestAuthService::test_create_tenant_token_with_roles
tests/unit/test_auth_service.py::TestAuthService::test_create_tenant_token_without_db
  /Volumes/Stuff/Start Ups/MoranERP/Backend/app/services/auth_service.py:30: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

tests/unit/test_auth_service.py::TestAuthService::test_create_access_token_custom_expiry
  /Volumes/Stuff/Start Ups/MoranERP/Backend/app/services/auth_service.py:28: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    expire = datetime.utcnow() + expires_delta

tests/unit/test_import_service.py::TestImportService::test_import_users_success
  /Volumes/Stuff/Start Ups/MoranERP/Backend/app/services/import_service.py:103: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    joined_at=datetime.utcnow()

tests/unit/test_onboarding_service_expanded.py::TestOnboardingOrchestratorExpanded::test_execute_next_step_no_pending
  /Volumes/Stuff/Start Ups/MoranERP/Backend/app/services/onboarding_service.py:518: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    step.started_at = datetime.utcnow()

tests/unit/test_onboarding_service_expanded.py::TestOnboardingOrchestratorExpanded::test_execute_next_step_no_pending
  /Volumes/Stuff/Start Ups/MoranERP/Backend/app/services/onboarding_service.py:584: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    enabled_at=datetime.utcnow(),

tests/unit/test_onboarding_service_expanded.py::TestOnboardingOrchestratorExpanded::test_execute_next_step_no_pending
  /Volumes/Stuff/Start Ups/MoranERP/Backend/app/services/onboarding_service.py:593: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    "created_at": datetime.utcnow().isoformat(),

tests/unit/test_onboarding_service_expanded.py::TestOnboardingOrchestratorExpanded::test_execute_next_step_no_pending
  /Volumes/Stuff/Start Ups/MoranERP/Backend/app/services/onboarding_service.py:535: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    step.completed_at = datetime.utcnow()

tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_chart_of_accounts_success
tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_chart_of_accounts_idempotent
  /Volumes/Stuff/Start Ups/MoranERP/Backend/app/services/engine_health_service.py:179: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    checked_at=datetime.utcnow()

tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_chart_of_accounts_success
tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_chart_of_accounts_idempotent
  /Volumes/Stuff/Start Ups/MoranERP/Backend/app/services/engine_health_service.py:113: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    self._cache[cache_key] = (result, datetime.utcnow())

tests/unit/test_rbac_models.py::TestUserRoleModel::test_user_role_expired
tests/unit/test_rbac_models.py::TestUserRoleModel::test_user_role_expired
  /Volumes/Stuff/Start Ups/MoranERP/Backend/app/models/rbac.py:97: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    return datetime.utcnow() > self.expires_at

tests/unit/test_rbac_models.py::TestPermissionOverrideModel::test_permission_override_expired
tests/unit/test_rbac_models.py::TestPermissionOverrideModel::test_permission_override_expired
  /Volumes/Stuff/Start Ups/MoranERP/Backend/app/models/rbac.py:126: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    return datetime.utcnow() > self.expires_at

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
================================ tests coverage ================================
_______________ coverage: platform darwin, python 3.13.5-final-0 _______________

Name                                            Stmts   Miss   Cover   Missing
------------------------------------------------------------------------------
app/api/v2/pos.py                                 135     70  48.15%   135-206, 229-257, 278-292, 314-325, 347-365, 386-422, 433-451, 456-462, 467-489
app/config.py                                      37      6  83.78%   49, 52-56
app/database.py                                    11      4  63.64%   12-16
app/dependencies/auth.py                          119     60  49.58%   94, 97-106, 110, 130-180, 230-281
app/dependencies/permissions.py                    90     19  78.89%   50-51, 97, 106-107, 152, 161-162, 199-216, 245-246, 285
app/dependencies/tenant.py                         20      6  70.00%   12-20
app/exceptions/__init__.py                          2      0 100.00%
app/exceptions/provisioning.py                     16      5  68.75%   40-42, 54-55
app/main.py                                        83      3  96.39%   103, 111, 115
app/middleware/__init__.py                          0      0 100.00%
app/middleware/pos_cache_middleware.py            152     94  38.16%   45, 53-63, 76-90, 108-109, 116, 123, 131-153, 158-172, 197, 203-229, 233-251, 255-264, 268-280, 284-296
app/middleware/response_normalizer.py              43     17  60.47%   47, 69, 120-143, 159
app/models/erp_modules.py                          35      0 100.00%
app/models/iam.py                                 169      1  99.41%   10
app/models/onboarding.py                          120      0 100.00%
app/models/paint.py                               100      0 100.00%
app/models/payment_reference.py                    52     12  76.92%   63, 68, 73, 77-84, 88, 92
app/models/pos_profile.py                          44      0 100.00%
app/models/pos_session.py                          63      0 100.00%
app/models/pos_warehouse_access.py                 24      0 100.00%
app/models/rbac.py                                100      0 100.00%
app/routers/accounting.py                         283    203  28.27%   16-19, 35-48, 63-65, 75-77, 89-91, 108-110, 127-145, 156-158, 168-186, 196-206, 222-224, 243-245, 255-257, 273-275, 294-296, 313-315, 325-329, 347-351, 361-363, 373-377, 389-391, 410-412, 422-426, 449-453, 465-467, 477-479, 489-508, 519-530, 540-548, 558-574, 584-594, 606-608, 627-629, 646-664, 675-677, 687-696, 714-724
app/routers/assets.py                              55     29  47.27%   30, 42-44, 54-56, 66-70, 81-83, 95-97, 107-109, 119-123, 134-136
app/routers/audit.py                              143    111  22.38%   57-161, 182-284, 295-299, 314-366
app/routers/auth.py                               131     86  34.35%   37-71, 100-104, 127, 140-174, 210-288, 309-358
app/routers/commissions.py                        136     98  27.94%   64-142, 161-225, 237-295, 309-334, 349-369, 383-390
app/routers/crm.py                                247    162  34.41%   24-27, 31-32, 45-70, 82-84, 94-96, 106-110, 121-123, 133-135, 145-147, 157-159, 169-173, 184-186, 196-198, 208-210, 221-229, 239-243, 254-256, 266-268, 284-286, 304-312, 322-326, 337-339, 349-351, 367-369, 387-395, 413-427, 438-440, 457-464, 484-486, 502-504, 521-523, 533-577, 588-590, 601-613, 627-643, 655-657, 675-677, 687-691, 702-703
app/routers/dashboard.py                          165    139  15.76%   36-81, 99-146, 159-204, 223-287, 296-325, 330-367, 372-399, 404-426, 433-459, 466-495, 502-530
app/routers/erp.py                                 36      9  75.00%   32, 40, 49-57, 73, 76-86
app/routers/erp_modules.py                         91     73  19.78%   82-117, 134-161, 178-250, 270-296, 316-336
app/routers/erpnext.py                            207    149  28.02%   26-69, 101-254, 274, 301, 305-324, 328-347, 351-371, 381-414, 433, 460, 487
app/routers/files.py                              159    112  29.56%   59-61, 66-70, 75-79, 94-152, 166-192, 213-257, 271-297, 311-332, 346-369
app/routers/hr.py                                 219    142  35.16%   18-19, 31-33, 54-79, 89-167, 176-178, 189-197, 213-223, 238-251, 263-265, 275-277, 287-290, 299-301, 311-312, 324-326, 336-338, 348-351, 360-362, 372-373, 385-387, 397-399, 409-412, 423-425, 435-436, 448-456, 466-476, 486-497, 508-518, 528-537, 549-551, 568-570, 582-584, 603-605, 617-619, 629-631
app/routers/i18n.py                                78     54  30.77%   32, 51-68, 90-99, 123-143, 167-187, 210-218, 242-268, 290-293
app/routers/iam.py                                368    303  17.66%   26-35, 92-515, 532-604, 620-633, 655-684, 716-777, 800-815, 832-843, 865-926, 943-945, 970-1009, 1027-1069
app/routers/imports.py                             54     38  29.63%   31-35, 46-67, 77-98
app/routers/inventory.py                          672    536  20.24%   120-142, 152-158, 168-175, 187-195, 205-211, 234-270, 284-309, 319-330, 341-371, 381-435, 451-512, 524-737, 747-781, 790-798, 814-932, 971-1075, 1092-1099, 1110-1154, 1164-1165, 1184-1345, 1358-1459, 1469-1476, 1488-1506, 1516-1553, 1568-1622, 1637-1654, 1669-1682, 1696-1709
app/routers/manufacturing.py                      146     92  36.99%   16-19, 32-35, 45-48, 58-62, 73-76, 86-88, 98-101, 111-114, 124-128, 139-142, 152-154, 166-169, 186-189, 207-225, 234-237, 247-248, 266-267, 279-282, 300-303, 313-317, 326-329, 341-344, 361-364, 374-378
app/routers/notifications.py                      162    106  34.57%   64, 69-73, 90-116, 128-140, 154-190, 201-215, 226-246, 256-274, 285-305, 315-334, 351-367
app/routers/odoo.py                                18      7  61.11%   27-34, 56-62
app/routers/onboarding.py                         166     96  42.17%   139-171, 189-202, 222-249, 271-292, 305-320, 338-351, 369-382, 396-423, 447-472, 500-507, 538-550, 572-631
app/routers/paint.py                              166    134  19.28%   42-52, 79-108, 126-144, 172-191, 206-216, 240-288, 306-321, 351-477, 497-580
app/routers/permissions.py                        125     75  40.00%   79-124, 136-172, 184-223, 241, 274-301, 313-317, 330-355, 369-391, 403-419
app/routers/pos.py                                720    602  16.39%   52-61, 140-176, 186-193, 204-282, 299-400, 417-556, 567-572, 584-599, 609-615, 625-632, 643-649, 659-664, 676-691, 702-712, 727-1372, 1385-1407, 1417-1424, 1434-1451, 1462-1478, 1494-1510, 1530-1544, 1557-1607, 1625-1667
app/routers/pos_analytics.py                      192    138  28.12%   70-90, 112-128, 153-171, 195-212, 236-253, 277-294, 317-344, 366-376, 397-407, 423-550, 556, 571, 583, 595, 606, 616, 627-628, 634
app/routers/pos_layaway.py                         49     18  63.27%   48-61, 71-73, 83-90, 100-102, 113-119
app/routers/pos_loyalty.py                         52     23  55.77%   46-48, 58-60, 70-83, 93-103, 113-120
app/routers/pos_orders.py                          57     35  38.60%   32-40, 57-61, 75-79, 94-101, 116-124, 138-142, 156-178
app/routers/pos_payments.py                       195    121  37.95%   76-84, 100-147, 169-212, 234-283, 305-318, 343-361, 383-395, 417-432, 454-470, 492-504, 526-545, 567-575, 598-609, 631-642
app/routers/pos_profiles.py                        52     34  34.62%   33-44, 61-69, 84-88, 104-123, 138-142
app/routers/pos_quick_actions.py                   94     71  24.47%   35-54, 79-98, 123-142, 167-204, 228-258, 281-330, 354-398
app/routers/pos_receipts.py                       102     83  18.63%   35-87, 112-152, 177-218, 243-284, 310-390
app/routers/pos_sessions.py                        78     60  23.08%   31-41, 57-65, 79-83, 98-105, 125-229
app/routers/pos_sync.py                           102     71  30.39%   38-42, 64-72, 95-107, 131-171, 193-205, 228-263, 284-297, 319-359, 383-397
app/routers/pos_warehouse_access.py               139    102  26.62%   32-36, 43-56, 60-70, 74-87, 98-107, 125-153, 173-187, 198-207, 225-253, 273-287
app/routers/projects.py                            99     60  39.39%   15-18, 30-33, 43-46, 56-60, 71-74, 84-86, 102-105, 123-126, 136-140, 149-152, 168-171, 189-192, 202-206, 215-218, 230-233, 250-253, 263-267
app/routers/provisioning.py                       316    268  15.19%   86-232, 253-340, 365-470, 494-615, 637-677, 698-723
app/routers/purchases.py                          184     72  60.87%   116-127, 138-141, 152-155, 167-171, 182-185, 206, 208, 210, 212, 215, 240-243, 255-258, 269-272, 283-286, 299-302, 316-327, 338-341, 354-357, 371-382, 393-396
app/routers/quality.py                             55     29  47.27%   29, 41-43, 53-55, 65-69, 80-82, 94-96, 106-108, 118-122, 133-135
app/routers/rbac.py                               110     16  85.45%   104, 136, 144, 149, 154, 171-172, 189, 197, 209, 223-245
app/routers/reports.py                            150     97  35.33%   79-124, 145-180, 199-205, 221-266, 275-327, 334-382, 389-425, 432-464, 471-494, 501-525
app/routers/roles.py                              217    156  28.11%   104-152, 164-199, 230-294, 323-368, 397-448, 460-480, 508-574, 590-640
app/routers/sales.py                              102     60  41.18%   31, 43-45, 55-57, 67-71, 82-84, 96-98, 108-110, 120-124, 135-137, 149-151, 161-163, 173-177, 188-190, 202-205, 215-219, 229-236, 247-249
app/routers/settings.py                           366    130  64.48%   43, 46-53, 166-168, 205-207, 245-247, 267-303, 364-420, 440-512, 591-613, 632-653
app/routers/support.py                             33     15  54.55%   29, 41-43, 53-55, 65-69, 80-82
app/routers/tenant_setup.py                        85     65  23.53%   30-44, 55-125, 134-203
app/routers/user_roles.py                         168    105  37.50%   99-142, 160-235, 256-294, 307-327, 340-375, 394-455, 487-528
app/services/auth_service.py                       84     23  72.62%   111-115, 134-172
app/services/cache/pos_cache.py                   255    217  14.90%   55-78, 91-110, 123-146, 158-177, 191-213, 226-245, 259-282, 295-314, 328-350, 363-382, 394-411, 424-451, 464-524, 533-561, 573-596
app/services/cache_service.py                      94     39  58.51%   7-9, 34-38, 52, 81, 86-87, 98, 106-107, 116-123, 136, 143-146, 162-169, 173-181
app/services/engine_adapter.py                     12      1  91.67%   164
app/services/engine_health_service.py             133     78  41.35%   99-104, 122-149, 172, 174, 181-198, 213-248, 263-305, 328-342, 361-362, 372-382
app/services/erpnext_client.py                    402    215  46.52%   73-77, 85-98, 109-111, 114-116, 121-123, 125-127, 129-131, 153-155, 181, 183, 205, 209-210, 245-247, 264-271, 275, 293-294, 298, 310-318, 322-323, 328-329, 338-361, 365-377, 384, 394-424, 434, 444-450, 464-465, 491-558, 561, 566, 572-578, 589, 602, 629, 656, 676-687, 708-717, 736-772, 791-833, 867-928, 958-998, 1025-1066, 1086-1087, 1091, 1095
app/services/erpnext_purchase_service.py          129    100  22.48%   26-49, 60-69, 76-82, 90-99, 106-113, 123-150, 157-166, 173-179, 187-196, 203-210, 217-224, 233-242, 250-273, 280-286, 295-304, 312-335, 342-348, 354, 367, 382, 405-407, 425, 443, 453, 473
app/services/i18n/pos_translations.py              82     45  45.12%   44, 48-50, 204-214, 228-233, 247-252, 266-271, 284-289, 301-303, 322-323, 332, 347, 359-361
app/services/import_service.py                    123     43  65.04%   44, 114-116, 122-128, 136-164, 170, 175-190, 199, 204-220
app/services/odoo_client.py                       123     47  61.79%   31, 46, 63, 69-73, 92-113, 133-153, 175, 195-241, 254-272, 288-289, 302-303, 315-316, 329-330, 342-343, 347-358
app/services/onboarding_service.py                223    113  49.33%   111-118, 124-135, 170, 178-225, 229-248, 264, 268-269, 272, 282-285, 300, 305-309, 313-325, 329-344, 391-402, 411-429, 439-474, 511, 526, 530, 540-548, 559, 601, 609, 619
app/services/paint_service.py                      83     72  13.25%   16-17, 21-33, 44-60, 68-106, 110-159, 163-199
app/services/payments/mobile_money_service.py     177    144  18.64%   20-21, 46, 53-58, 62-78, 88-123, 131-149, 158-170, 177-181, 185-200, 210-245, 255-256, 265-277, 288-293, 297, 301, 317-355, 378-408, 429-442, 450-451
app/services/payments/mpesa_service.py            136     89  34.56%   60-63, 67-90, 94, 98, 119-159, 174-200, 213-223, 227, 239-282, 303-341, 345
app/services/pos/__init__.py                        0      0 100.00%
app/services/pos/accounting_integration.py         66     55  16.67%   19, 34-40, 60-80, 97-116, 133-153, 170-174, 194-202, 225-229
app/services/pos/erpnext_pos_service.py           321    285  11.21%   29-36, 40-48, 55-76, 85-120, 125-185, 192, 196, 214-256, 260-264, 268-277, 281-355, 375-404, 408-413, 417-418, 435-475, 479-483, 487-514, 518-519, 528-543, 552-562, 573-591, 595-596, 604-616, 625-634, 638-640, 646-666, 670-692, 696-732
app/services/pos/event_bus.py                     209    138  33.97%   41-46, 50-53, 58-60, 75-94, 158-178, 191-203, 230-249, 253-268, 272-297, 301-305, 309-326, 330, 341-368, 387-402, 406-408, 412-426, 435-437, 443, 453, 463, 473
app/services/pos/gl_distribution_service.py        74     49  33.78%   47-111, 146, 163, 180, 201-219, 238-255, 276-279
app/services/pos/inventory_integration.py          99     87  12.12%   21-22, 39-106, 110-128, 131-171, 181-229, 251, 269, 289-303
app/services/pos/layaway_service.py               151    127  15.89%   59-114, 139-162, 181-248, 263-296, 300-303, 307, 311, 323-363, 379-425, 440-468, 477, 486-487
app/services/pos/loyalty_service.py               133    106  20.30%   52-78, 92-93, 97-119, 134-161, 175-217, 234-265, 277-291, 303, 315-324, 337-360, 378-418, 427, 436-437
app/services/pos/offline_service.py               211    145  31.28%   37-42, 48-51, 68-69, 114-118, 141-153, 170-199, 206-234, 241-254, 261-281, 298-346, 350-354, 366-384, 410-411, 435-464, 481-497, 506
app/services/pos/plugin_registry.py               169    108  36.09%   111-116, 121, 125-126, 176-198, 210-232, 236-246, 250-257, 272-273, 279, 283, 287, 291, 295, 303, 316-336, 348-381, 385-396, 405
app/services/pos/pos_service_base.py                4      0 100.00%
app/services/pos/pos_service_factory.py            16      7  56.25%   36-56
app/services/pos/quick_actions_service.py         139    116  16.55%   36-38, 57-129, 148-230, 249-297, 316-329, 346-382, 386-394, 398-404
app/services/pos/receipt_service.py               200    174  13.00%   27, 31-37, 56-132, 151-274, 291-362, 385-387, 415-417, 427, 431-444, 448-459, 463-474
app/services/pos/vat_service.py                    45     19  57.78%   37-47, 75-77, 116-119, 133-143, 156-162
app/services/provisioning_service.py             1330   1054  20.75%   58-158, 177-226, 274, 336, 360-365, 382-390, 395-396, 427-429, 457-534, 575, 595, 620, 643-676, 696-716, 747-930, 947-1192, 1220-1278, 1297-1298, 1311-1320, 1345-1366, 1407-1420, 1433, 1452-1514, 1520-1522, 1542, 1559-1611, 1614, 1635-1638, 1660-1661, 1681-1688, 1695-1700, 1702, 1724-1729, 1743-1936, 1962-1975, 2026-2037, 2081-2093, 2116-2128, 2148-2151, 2168-2492, 2509-2680, 2697-2867, 2882-2890, 2920-3238
app/services/purchase_service_base.py               3      0 100.00%
app/services/purchase_service_factory.py            8      5  37.50%   27-36
app/services/rbac_service.py                      103     18  82.52%   104-114, 138, 162, 171-177, 487-497
app/utils/codes.py                                 59      7  88.14%   80-82, 91-95, 133
------------------------------------------------------------------------------
TOTAL                                           14355   9208  35.86%
Coverage HTML written to dir htmlcov
Coverage XML written to file coverage.xml
FAIL Required test coverage of 80% not reached. Total coverage: 35.86%
=========================== short test summary info ============================
FAILED tests/integration/test_accounting_api.py::TestAccountingAPI::test_list_gl_entries
FAILED tests/integration/test_accounting_api.py::TestAccountingAPI::test_list_journals
FAILED tests/integration/test_accounting_api.py::TestAccountingAPI::test_list_accounts
FAILED tests/integration/test_accounting_api.py::TestAccountingAPI::test_create_journal_entry
FAILED tests/integration/test_auth_api.py::TestAuthAPI::test_login_success - ...
FAILED tests/integration/test_auth_api.py::TestAuthAPI::test_login_invalid_credentials
FAILED tests/integration/test_auth_api.py::TestAuthAPI::test_login_with_tenant_success
FAILED tests/integration/test_auth_api.py::TestAuthAPI::test_login_with_tenant_no_membership
FAILED tests/integration/test_auth_api.py::TestAuthAPI::test_get_user_memberships
FAILED tests/integration/test_crm_api.py::TestCRMAPI::test_list_contacts - as...
FAILED tests/integration/test_crm_api.py::TestCRMAPI::test_list_customers - a...
FAILED tests/integration/test_crm_api.py::TestCRMAPI::test_create_lead - asse...
FAILED tests/integration/test_erp_modules_api.py::TestERPModulesAPI::test_list_erp_modules
FAILED tests/integration/test_hr_api.py::TestHRAPI::test_list_employees - Att...
FAILED tests/integration/test_hr_api.py::TestHRAPI::test_create_employee - At...
FAILED tests/integration/test_hr_api.py::TestHRAPI::test_list_attendance - At...
FAILED tests/integration/test_inventory_api.py::TestInventoryAPI::test_list_items
FAILED tests/integration/test_inventory_api.py::TestInventoryAPI::test_create_item
FAILED tests/integration/test_inventory_api.py::TestInventoryAPI::test_get_item
FAILED tests/integration/test_inventory_api.py::TestInventoryAPI::test_list_warehouses
FAILED tests/integration/test_inventory_api.py::TestInventoryAPI::test_get_stock_balance
FAILED tests/integration/test_manufacturing_api.py::TestManufacturingAPI::test_list_work_orders
FAILED tests/integration/test_pos_invoice_integration.py::TestPOSInvoiceIntegration::test_complete_invoice_creation_flow
FAILED tests/integration/test_pos_invoice_integration.py::TestPOSInvoiceIntegration::test_vat_calculation_integration
FAILED tests/integration/test_pos_invoice_integration.py::TestPOSInvoiceIntegration::test_gl_distribution_integration
FAILED tests/integration/test_pos_invoice_integration.py::TestPOSInvoiceIntegration::test_pos_profile_validation
FAILED tests/integration/test_pos_invoice_integration.py::TestPOSInvoiceIntegration::test_payment_amount_validation
FAILED tests/integration/test_pos_invoice_integration.py::TestPOSInvoiceIntegration::test_offline_transaction_queue
FAILED tests/integration/test_pos_invoice_integration.py::TestPOSInvoiceIntegration::test_api_response_format
FAILED tests/integration/test_projects_api.py::TestProjectsAPI::test_list_projects
FAILED tests/integration/test_projects_api.py::TestProjectsAPI::test_list_tasks
FAILED tests/integration/test_projects_api.py::TestProjectsAPI::test_create_project
FAILED tests/integration/test_purchases_api.py::TestPurchasesAPI::test_list_purchase_orders
FAILED tests/test_health.py::test_health_check - TypeError: 'module' object i...
FAILED tests/test_health.py::test_root - TypeError: 'module' object is not ca...
FAILED tests/unit/test_dependencies_auth.py::TestRequireTenantAccess::test_require_tenant_access_super_admin
FAILED tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_login_success
FAILED tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_login_failure
FAILED tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_login_exception
FAILED tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_proxy_request_success
FAILED tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_proxy_request_error_handling
FAILED tests/unit/test_erpnext_client.py::TestERPNextClientAdapter::test_proxy_request_non_json_error
FAILED tests/unit/test_gl_distribution_service.py::TestGLDistributionService::test_build_gl_entries_cash_payment
FAILED tests/unit/test_gl_distribution_service.py::TestGLDistributionService::test_build_gl_entries_mpesa_payment
FAILED tests/unit/test_gl_distribution_service.py::TestGLDistributionService::test_build_gl_entries_multiple_payments
FAILED tests/unit/test_gl_distribution_service.py::TestGLDistributionService::test_build_gl_entries_multiple_items
FAILED tests/unit/test_gl_distribution_service.py::TestGLDistributionService::test_build_gl_entries_no_taxes
FAILED tests/unit/test_gl_distribution_service.py::TestGLDistributionService::test_rounding_precision_gl_entries
FAILED tests/unit/test_import_service_expanded.py::TestImportServiceExpanded::test_import_inventory_items
FAILED tests/unit/test_import_service_expanded.py::TestImportServiceExpanded::test_import_warehouses
FAILED tests/unit/test_import_service_expanded.py::TestImportServiceExpanded::test_import_storefronts
FAILED tests/unit/test_import_service_expanded.py::TestImportServiceExpanded::test_import_users_with_existing
FAILED tests/unit/test_onboarding_service.py::TestOnboardingOrchestrator::test_initiate_onboarding_success
FAILED tests/unit/test_onboarding_service_expanded.py::TestOnboardingOrchestratorExpanded::test_skip_step_success
FAILED tests/unit/test_onboarding_service_expanded.py::TestOnboardingOrchestratorExpanded::test_skip_step_not_found
FAILED tests/unit/test_onboarding_service_expanded.py::TestOnboardingOrchestratorExpanded::test_execute_next_step_no_pending
FAILED tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_engine_check_success
FAILED tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_engine_check_offline
FAILED tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_company_creation_success
FAILED tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_company_creation_idempotent
FAILED tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_chart_of_accounts_success
FAILED tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_chart_of_accounts_idempotent
FAILED tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_warehouses_success
FAILED tests/unit/test_provisioning_service.py::TestProvisioningService::test_step_settings_success
FAILED tests/unit/test_provisioning_service.py::TestProvisioningService::test_provisioning_full_flow_success
FAILED tests/unit/test_provisioning_service.py::TestProvisioningService::test_provisioning_critical_failure
FAILED tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_grant_permission_override_success
FAILED tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_grant_permission_override_existing
FAILED tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_revoke_permission_override_success
FAILED tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_revoke_permission_override_not_found
FAILED tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_get_user_roles_system_wide
FAILED tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_get_effective_permissions_with_wildcards
FAILED tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_has_permission_with_override
FAILED tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_has_permission_with_override_denied
FAILED tests/unit/test_rbac_service_expanded2.py::TestRBACServiceAdditional::test_assign_role_with_expiry
FAILED tests/unit/test_vat_service.py::TestVATService::test_calculate_vat_vatable_item
FAILED tests/unit/test_vat_service.py::TestVATService::test_calculate_vat_non_vatable_item
FAILED tests/unit/test_vat_service.py::TestVATService::test_calculate_vat_for_items_mixed
FAILED tests/unit/test_vat_service.py::TestVATService::test_calculate_vat_for_items_empty
FAILED tests/unit/test_vat_service.py::TestVATService::test_calculate_vat_for_items_none_values
FAILED tests/unit/test_vat_service.py::TestVATService::test_rounding_precision
FAILED tests/unit/test_vat_service.py::TestVATService::test_zero_amount_handling
FAILED tests/unit/test_vat_service.py::TestVATService::test_negative_amount_handling
ERROR tests/integration/test_provisioning_api.py::TestProvisioningAPI::test_start_provisioning_success
ERROR tests/integration/test_provisioning_api.py::TestProvisioningAPI::test_start_provisioning_engine_offline
ERROR tests/integration/test_provisioning_api.py::TestProvisioningAPI::test_get_provisioning_status
ERROR tests/integration/test_provisioning_api.py::TestProvisioningAPI::test_get_provisioning_status_not_started
ERROR tests/integration/test_provisioning_api.py::TestProvisioningAPI::test_retry_provisioning
ERROR tests/integration/test_provisioning_api.py::TestProvisioningAPI::test_skip_step
ERROR tests/integration/test_provisioning_api.py::TestProvisioningAPI::test_get_provisioning_logs
ERROR tests/integration/test_provisioning_api.py::TestProvisioningAPI::test_concurrent_provisioning_prevention
ERROR tests/integration/test_provisioning_e2e.py::TestProvisioningE2E::test_e2e_workspace_to_pos_ready
ERROR tests/integration/test_provisioning_e2e.py::TestProvisioningE2E::test_e2e_pos_invoice_after_provisioning
ERROR tests/integration/test_provisioning_e2e.py::TestProvisioningE2E::test_e2e_verify_all_resources_created
====== 83 failed, 262 passed, 1 skipped, 53 warnings, 11 errors in 8.46s =======
